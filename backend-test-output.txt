============================= test session starts ==============================
platform darwin -- Python 3.12.12, pytest-8.3.4, pluggy-1.6.0
rootdir: /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator
configfile: pyproject.toml
plugins: anyio-4.12.1, asyncio-0.24.0, cov-6.0.0, hypothesis-6.122.3, mock-3.14.0, forked-1.6.0, xdist-3.6.1
asyncio: mode=Mode.STRICT, default_loop_scope=function
collected 1371 items

tests/unit/test_account_breakdown_completeness_property.py .             [  0%]
tests/unit/test_account_consistency_property.py ..                       [  0%]
tests/unit/test_account_utils_property.py .............                  [  1%]
tests/unit/test_account_utils_unit.py .................................. [  3%]
..............................                                           [  5%]
tests/unit/test_active_region_filtering_property.py ...........          [  6%]
tests/unit/test_active_region_tag_sync_property.py .......               [  7%]
tests/unit/test_audit_logging_failures.py .....................          [  8%]
tests/unit/test_aws_approved_fields_property.py .......                  [  9%]
tests/unit/test_callback_handler_property.py ....                        [  9%]
tests/unit/test_cli_operation_response_structure_property.py .....       [  9%]
tests/unit/test_combined_capacity_aggregation_property.py .......        [ 10%]
tests/unit/test_config_merge_property.py ....                            [ 10%]
tests/unit/test_conflict_detection_comprehensive.py .................... [ 12%]
.                                                                        [ 12%]
tests/unit/test_create_protection_group_launch_config_integration.py ... [ 12%]
...                                                                      [ 12%]
tests/unit/test_cross_account_audit.py ................                  [ 13%]
tests/unit/test_cross_account_unit.py ......................             [ 15%]
tests/unit/test_data_management_account_context.py .............         [ 16%]
tests/unit/test_data_management_apply_launch_configs.py ..............   [ 17%]
tests/unit/test_data_management_get_launch_config_status.py .......      [ 17%]
tests/unit/test_data_management_new_operations.py ...................... [ 19%]
.........                                                                [ 20%]
tests/unit/test_data_management_operations_property.py .............     [ 21%]
tests/unit/test_data_management_response_format.py ..........            [ 21%]
tests/unit/test_data_management_staging_accounts.py ..........           [ 22%]
tests/unit/test_data_management_staging_sync_routing.py .....            [ 22%]
tests/unit/test_dr_orchestration_handler_invocations.py ................ [ 24%]
..                                                                       [ 24%]
tests/unit/test_empty_staging_accounts_default_property.py ..            [ 24%]
tests/unit/test_error_handling_data_management_handler.py .............. [ 25%]
.........                                                                [ 26%]
tests/unit/test_error_handling_execution_handler.py .................... [ 27%]
                                                                         [ 27%]
tests/unit/test_error_handling_property.py .........                     [ 28%]
tests/unit/test_error_handling_query_handler.py ...................      [ 29%]
tests/unit/test_eventbridge_cfn_validation.py .........                  [ 30%]
tests/unit/test_execution_handler_accountcontext_fix.py .........        [ 30%]
tests/unit/test_execution_handler_direct_invocation.py ................. [ 32%]
                                                                         [ 32%]
tests/unit/test_execution_handler_direct_invocation_property.py .......  [ 32%]
tests/unit/test_execution_handler_operations.py ..................       [ 33%]
tests/unit/test_execution_handler_response_format.py ...........         [ 34%]
tests/unit/test_execution_handler_start_wave.py .......................  [ 36%]
tests/unit/test_execution_handler_wave_optimization.py ................. [ 37%]
                                                                         [ 37%]
tests/unit/test_execution_orchestration_handlers.py .................... [ 39%]
.....                                                                    [ 39%]
tests/unit/test_failed_account_resilience_property.py .....              [ 39%]
tests/unit/test_handle_add_staging_account.py ........                   [ 40%]
tests/unit/test_handle_get_combined_capacity.py .......                  [ 40%]
tests/unit/test_iam_audit_logging_property.py ............               [ 41%]
tests/unit/test_iam_principal_extraction.py ....................         [ 43%]
tests/unit/test_iam_utils.py .....................                       [ 44%]
tests/unit/test_iam_utils_property.py .................                  [ 46%]
tests/unit/test_iam_utils_unit.py ......................FFFFFFF......... [ 48%]
FF.                                                                      [ 49%]
tests/unit/test_inventory_fallback_property.py F..FFF..                  [ 49%]
tests/unit/test_inventory_query_property.py FFFFF                        [ 49%]
tests/unit/test_inventory_query_unit.py F.....FFFFFF...FFFF..            [ 51%]
tests/unit/test_inventory_sync_property.py FFF...F.                      [ 52%]
tests/unit/test_launch_config_schema_property.py .........               [ 52%]
tests/unit/test_launch_config_schema_unit.py .........                   [ 53%]
tests/unit/test_launch_config_service_property.py ............FFFFF.FFFF [ 54%]
....F.F.F.....FFFFFF.F..........                                         [ 57%]
tests/unit/test_launch_config_service_unit.py ...........FFF........FFFF [ 59%]
...FF......F..........................                                   [ 61%]
tests/unit/test_multi_account_query_parallelism_property.py FFFFFF       [ 62%]
tests/unit/test_notification_formatter_html.py ......................... [ 64%]
.                                                                        [ 64%]
tests/unit/test_notification_formatter_property.py ..                    [ 64%]
tests/unit/test_notifications_property.py .......                        [ 64%]
tests/unit/test_notifications_publishing_unit.py ....................... [ 66%]
.................                                                        [ 67%]
tests/unit/test_notifications_subscription_unit.py ................      [ 69%]
tests/unit/test_orchestration_handler_role_arn.py ........               [ 69%]
tests/unit/test_per_account_status_calculation_property.py ............. [ 70%]
....                                                                     [ 70%]
tests/unit/test_poll_wave_status.py ...........                          [ 71%]
tests/unit/test_pre_creation_quota_validation.py ..............          [ 72%]
tests/unit/test_query_handler_action_routing.py .....                    [ 73%]
tests/unit/test_query_handler_get_server_config_history.py ...........   [ 73%]
tests/unit/test_query_handler_get_server_launch_config.py ........       [ 74%]
tests/unit/test_query_handler_invocation_modes.py ...................... [ 76%]
.....                                                                    [ 76%]
tests/unit/test_query_handler_new_operations.py ...................      [ 77%]
tests/unit/test_query_handler_new_operations_property.py ..............  [ 78%]
tests/unit/test_query_handler_poll_wave.py ......................        [ 80%]
tests/unit/test_query_handler_query_servers.py ........................  [ 82%]
tests/unit/test_query_handler_read_only.py ....                          [ 82%]
tests/unit/test_query_handler_response_format.py ..........              [ 83%]
tests/unit/test_query_handler_role_arn.py ...........                    [ 84%]
tests/unit/test_rbac_permissions.py ......................               [ 85%]
tests/unit/test_recovery_capacity_calculation_property.py ..........     [ 86%]
tests/unit/test_response_format_property.py ........                     [ 86%]
tests/unit/test_response_utils.py .................................      [ 89%]
tests/unit/test_security_utils_unit.py ................................. [ 91%]
.                                                                        [ 91%]
tests/unit/test_shared_protection_groups.py ...................          [ 93%]
tests/unit/test_staging_account_persistence_property.py ...              [ 93%]
tests/unit/test_staging_account_removal_property.py ....                 [ 93%]
tests/unit/test_staging_account_sync_comprehensive.py F...........F..... [ 95%]
                                                                         [ 95%]
tests/unit/test_staging_sync_property.py ....                            [ 95%]
tests/unit/test_tag_sync_property.py .......                             [ 95%]
tests/unit/test_target_account_addition_property.py .....                [ 96%]
tests/unit/test_update_protection_group_launch_config_integration.py ... [ 96%]
..                                                                       [ 96%]
tests/unit/test_update_wave_completion_status.py ...............         [ 97%]
tests/unit/test_validate_staging_account_edge_cases.py .............     [ 98%]
tests/unit/test_validation_error_handling_property.py .....              [ 98%]
tests/unit/test_validation_result_completeness_property.py ...           [ 99%]
tests/unit/test_warning_generation_property.py ...........               [100%]

=================================== FAILURES ===================================
____________ TestLogDirectInvocation.test_log_successful_invocation ____________

self = <tests.unit.test_iam_utils_unit.TestLogDirectInvocation object at 0x10d6ffc50>
mock_logger = <MagicMock name='logger' id='5128052064'>

    @patch("shared.iam_utils.logger")
    def test_log_successful_invocation(self, mock_logger):
        """Test logs successful invocation."""
        principal = "arn:aws:iam::123456789012:role/OrchestrationRole"
        operation = "get_drs_source_servers"
        params = {"region": "us-east-1"}
        result = {"servers": [], "totalCount": 0}
    
        log_direct_invocation(
            principal=principal, operation=operation, params=params, result=result, success=True
        )
    
        # Verify info log was called
>       assert mock_logger.info.called
E       AssertionError: assert False
E        +  where False = <MagicMock name='logger.info' id='5128059120'>.called
E        +    where <MagicMock name='logger.info' id='5128059120'> = <MagicMock name='logger' id='5128052064'>.info

tests/unit/test_iam_utils_unit.py:271: AssertionError
______________ TestLogDirectInvocation.test_log_failed_invocation ______________

self = <tests.unit.test_iam_utils_unit.TestLogDirectInvocation object at 0x10d6ffef0>
mock_logger = <MagicMock name='logger' id='4987888144'>

    @patch("shared.iam_utils.logger")
    def test_log_failed_invocation(self, mock_logger):
        """Test logs failed invocation."""
        principal = "arn:aws:iam::123456789012:user/unauthorized"
        operation = "get_drs_source_servers"
        params = {"region": "us-east-1"}
        result = {"error": "AUTHORIZATION_FAILED"}
    
        log_direct_invocation(
            principal=principal, operation=operation, params=params, result=result, success=False
        )
    
        # Verify warning log was called
>       assert mock_logger.warning.called
E       AssertionError: assert False
E        +  where False = <MagicMock name='logger.warning' id='5036381904'>.called
E        +    where <MagicMock name='logger.warning' id='5036381904'> = <MagicMock name='logger' id='4987888144'>.warning

tests/unit/test_iam_utils_unit.py:293: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  shared.iam_utils:iam_utils.py:407 {"timestamp": "2026-02-21T04:30:06.088092Z", "event_type": "direct_invocation", "principal": "arn:aws:iam::123456789012:user/unauthorized", "operation": "get_drs_source_servers", "parameters": {"region": "us-east-1"}, "result": {"error": "AUTHORIZATION_FAILED"}, "success": false}
_________ TestLogDirectInvocation.test_log_masks_sensitive_parameters __________

self = <tests.unit.test_iam_utils_unit.TestLogDirectInvocation object at 0x10d7181d0>
mock_logger = <MagicMock name='logger' id='5023655664'>

    @patch("shared.iam_utils.logger")
    def test_log_masks_sensitive_parameters(self, mock_logger):
        """Test masks sensitive parameters in logs."""
        principal = "arn:aws:iam::123456789012:role/OrchestrationRole"
        operation = "test_operation"
        params = {"password": "secret123", "token": "abc123def456", "region": "us-east-1"}
        result = {"success": True}
    
        log_direct_invocation(
            principal=principal, operation=operation, params=params, result=result, success=True
        )
    
>       log_call = mock_logger.info.call_args[0][0]
E       TypeError: 'NoneType' object is not subscriptable

tests/unit/test_iam_utils_unit.py:312: TypeError
___________ TestLogDirectInvocation.test_log_truncates_large_results ___________

self = <tests.unit.test_iam_utils_unit.TestLogDirectInvocation object at 0x10d718470>
mock_logger = <MagicMock name='logger' id='5023656960'>

    @patch("shared.iam_utils.logger")
    def test_log_truncates_large_results(self, mock_logger):
        """Test truncates large results in logs."""
        principal = "arn:aws:iam::123456789012:role/OrchestrationRole"
        operation = "get_drs_source_servers"
        params = {"region": "us-east-1"}
        # Create large result (> 1000 chars)
        result = {"servers": ["server" + str(i) for i in range(200)]}
    
        log_direct_invocation(
            principal=principal, operation=operation, params=params, result=result, success=True
        )
    
>       log_call = mock_logger.info.call_args[0][0]
E       TypeError: 'NoneType' object is not subscriptable

tests/unit/test_iam_utils_unit.py:338: TypeError
__________ TestLogDirectInvocation.test_log_includes_context_metadata __________

self = <tests.unit.test_iam_utils_unit.TestLogDirectInvocation object at 0x10d718710>
mock_logger = <MagicMock name='logger' id='4507659264'>

    @patch("shared.iam_utils.logger")
    def test_log_includes_context_metadata(self, mock_logger):
        """Test includes Lambda context metadata in logs."""
        principal = "arn:aws:iam::123456789012:role/OrchestrationRole"
        operation = "test_operation"
        params = {}
        result = {"success": True}
    
        context = Mock()
        context.aws_request_id = "abc-123-def-456"
        context.function_name = "query-handler"
        context.function_version = "$LATEST"
    
        log_direct_invocation(
            principal=principal, operation=operation, params=params, result=result, success=True, context=context
        )
    
>       log_call = mock_logger.info.call_args[0][0]
E       TypeError: 'NoneType' object is not subscriptable

tests/unit/test_iam_utils_unit.py:363: TypeError
_______ TestLogDirectInvocation.test_log_handles_nested_sensitive_params _______

self = <tests.unit.test_iam_utils_unit.TestLogDirectInvocation object at 0x10d7189b0>
mock_logger = <MagicMock name='logger' id='4553407136'>

    @patch("shared.iam_utils.logger")
    def test_log_handles_nested_sensitive_params(self, mock_logger):
        """Test masks sensitive parameters in nested dictionaries."""
        principal = "arn:aws:iam::123456789012:role/OrchestrationRole"
        operation = "test_operation"
        params = {"config": {"password": "secret123", "region": "us-east-1"}, "token": "abc123"}
        result = {"success": True}
    
        log_direct_invocation(
            principal=principal, operation=operation, params=params, result=result, success=True
        )
    
>       log_call = mock_logger.info.call_args[0][0]
E       TypeError: 'NoneType' object is not subscriptable

tests/unit/test_iam_utils_unit.py:382: TypeError
______________ TestLogDirectInvocation.test_log_handles_exception ______________

self = <tests.unit.test_iam_utils_unit.TestLogDirectInvocation object at 0x10d718c50>
mock_logger = <MagicMock name='logger' id='5070019840'>

    @patch("shared.iam_utils.logger")
    def test_log_handles_exception(self, mock_logger):
        """Test handles exception during logging."""
        principal = "arn:aws:iam::123456789012:role/OrchestrationRole"
        operation = "test_operation"
        # Create params that will cause JSON serialization error
        params = {"invalid": object()}
        result = {"success": True}
    
        # Should not raise exception
        log_direct_invocation(
            principal=principal, operation=operation, params=params, result=result, success=True
        )
    
        # Verify error was logged
>       assert mock_logger.error.called
E       AssertionError: assert False
E        +  where False = <MagicMock name='logger.error' id='5022588976'>.called
E        +    where <MagicMock name='logger.error' id='5022588976'> = <MagicMock name='logger' id='5070019840'>.error

tests/unit/test_iam_utils_unit.py:409: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.iam_utils:iam_utils.py:410 Error logging direct invocation: Object of type object is not JSON serializable
______ TestIntegrationScenarios.test_authorized_step_functions_invocation ______

self = <tests.unit.test_iam_utils_unit.TestIntegrationScenarios object at 0x10d71a270>
mock_logger = <MagicMock name='logger' id='4987528032'>

    @patch("shared.iam_utils.logger")
    def test_authorized_step_functions_invocation(self, mock_logger):
        """Test complete flow for authorized Step Functions invocation."""
        # Create Step Functions context
        context = Mock()
        context.invoked_function_arn = "arn:aws:sts::123456789012:assumed-role/StepFunctionsRole/execution-123"
        context.identity = None
        context.aws_request_id = "req-123"
        context.function_name = "query-handler"
        context.function_version = "$LATEST"
    
        # Extract principal
        principal = extract_iam_principal(context)
        assert "StepFunctionsRole" in principal
    
        # Validate authorization
        is_authorized = validate_iam_authorization(principal)
        assert is_authorized is True
    
        # Log successful invocation
        log_direct_invocation(
            principal=principal,
            operation="get_drs_source_servers",
            params={"region": "us-east-1"},
            result={"servers": [], "totalCount": 0},
            success=True,
            context=context,
        )
    
        # Verify audit log
>       assert mock_logger.info.called
E       AssertionError: assert False
E        +  where False = <MagicMock name='logger.info' id='4987533744'>.called
E        +    where <MagicMock name='logger.info' id='4987533744'> = <MagicMock name='logger' id='4987528032'>.info

tests/unit/test_iam_utils_unit.py:526: AssertionError
__________ TestIntegrationScenarios.test_unauthorized_user_invocation __________

self = <tests.unit.test_iam_utils_unit.TestIntegrationScenarios object at 0x10d71a510>
mock_logger = <MagicMock name='logger' id='4827917936'>

    @patch("shared.iam_utils.logger")
    def test_unauthorized_user_invocation(self, mock_logger):
        """Test complete flow for unauthorized user invocation."""
        # Create unauthorized user context
        context = Mock()
        context.invoked_function_arn = "arn:aws:iam::123456789012:user/unauthorized"
        context.identity = None
        context.aws_request_id = "req-456"
        context.function_name = "query-handler"
        context.function_version = "$LATEST"
    
        # Extract principal
        principal = extract_iam_principal(context)
        assert principal == "arn:aws:iam::123456789012:user/unauthorized"
    
        # Validate authorization
        is_authorized = validate_iam_authorization(principal)
        assert is_authorized is False
    
        # Log failed invocation
        log_direct_invocation(
            principal=principal,
            operation="get_drs_source_servers",
            params={"region": "us-east-1"},
            result=create_authorization_error_response(),
            success=False,
            context=context,
        )
    
        # Verify audit log
>       assert mock_logger.warning.called
E       AssertionError: assert False
E        +  where False = <MagicMock name='logger.warning' id='4827918512'>.called
E        +    where <MagicMock name='logger.warning' id='4827918512'> = <MagicMock name='logger' id='4827917936'>.warning

tests/unit/test_iam_utils_unit.py:558: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  shared.iam_utils:iam_utils.py:338 Authorization denied for principal: arn:aws:iam::123456789012:user/unauthorized. Principal does not match allowed patterns.
WARNING  shared.iam_utils:iam_utils.py:407 {"timestamp": "2026-02-21T04:30:06.117916Z", "event_type": "direct_invocation", "principal": "arn:aws:iam::123456789012:user/unauthorized", "operation": "get_drs_source_servers", "parameters": {"region": "us-east-1"}, "result": {"error": "AUTHORIZATION_FAILED", "message": "Insufficient permissions for direct invocation", "details": "Direct Lambda invocation requires OrchestrationRole or equivalent IAM permissions"}, "success": false, "request_id": "req-456", "function_name": "query-handler", "function_version": "$LATEST"}
______________ test_property_10_inventory_updated_during_fallback ______________

    @settings(max_examples=100, deadline=None)
>   @given(regions=region_list(), servers=st.lists(source_server_data(), min_size=1, max_size=5))

tests/unit/test_inventory_fallback_property.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

regions = ['us-east-1']
servers = [{'arn': 'arn:aws:drs:us-east-1:123456789012:source-server/s-00000000000000000', 'dataReplicationInfo': {'dataReplicationState': 'CONTINUOUS'}, 'hostname': '0', 'lifeCycle': {'state': 'READY_FOR_LAUNCH'}, ...}]

    @settings(max_examples=100, deadline=None)
    @given(regions=region_list(), servers=st.lists(source_server_data(), min_size=1, max_size=5))
    def test_property_10_inventory_updated_during_fallback(regions, servers):
        """
        Feature: active-region-filtering
        Property 10: Inventory Database Updates During Fallback
    
        For any operation that falls back to DRS API calls due to stale or missing
        inventory data, the operation should update the inventory database with the
        retrieved server data before returning results.
    
        Validates: Requirements 12.10
        """
        with patch("shared.inventory_query.get_inventory_table") as mock_table:
            with patch("shared.inventory_query._get_drs_client") as mock_get_client:
                with patch("shared.inventory_query.is_inventory_fresh") as mock_is_fresh:
                    # Setup: Mock inventory as stale (triggers fallback)
                    mock_is_fresh.return_value = False
    
                    # Setup: Mock DynamoDB table
                    mock_dynamodb_table = MagicMock()
                    mock_table.return_value = mock_dynamodb_table
    
                    # Setup: Mock inventory table returns empty (no cached data)
                    mock_dynamodb_table.query.return_value = {"Items": []}
    
                    # Setup: Mock DRS client
                    mock_drs_client = MagicMock()
                    mock_get_client.return_value = mock_drs_client
    
                    # Setup: Mock DRS API response (describe_source_servers returns items directly)
                    mock_drs_client.describe_source_servers.return_value = {"items": servers}
    
                    # Execute: Call query_inventory_by_regions with update_on_fallback=True
                    result = inventory_query.query_inventory_by_regions(regions, update_on_fallback=True)
    
                    # Verify: DRS API was called (fallback occurred)
>                   assert mock_get_client.called, "Should call DRS API when inventory is stale"
E                   AssertionError: Should call DRS API when inventory is stale
E                   assert False
E                    +  where False = <MagicMock name='_get_drs_client' id='4826580896'>.called
E                   Falsifying example: test_property_10_inventory_updated_during_fallback(
E                       regions=['us-east-1'],
E                       servers=[{'sourceServerID': 's-00000000000000000',
E                         'hostname': '0',
E                         'arn': 'arn:aws:drs:us-east-1:123456789012:source-server/s-00000000000000000',
E                         'tags': {},
E                         'dataReplicationInfo': {'dataReplicationState': 'CONTINUOUS'},
E                         'lifeCycle': {'state': 'READY_FOR_LAUNCH'},
E                         'sourceProperties': {'cpus': [{'cores': 1}],
E                          'ram': 1024,
E                          'disks': [],
E                          'identificationHints': {'awsInstanceID': 'arn:aws:ec2:us-east-1:123456789012:instance/i-00000000000000000'}}}],
E                   )

tests/unit/test_inventory_fallback_property.py:145: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
INFO     shared.inventory_query:inventory_query.py:227 Inventory is stale, falling back to DRS API and updating database
INFO     shared.inventory_query:inventory_query.py:578 Falling back to DRS API for 1 regions and updating inventory
WARNING  shared.inventory_query:inventory_query.py:94 Failed to publish CloudWatch metric InventoryDatabaseMisses: An error occurred (InvalidClientTokenId) when calling the PutMetricData operation: The security token included in the request is invalid.
ERROR    shared.inventory_query:inventory_query.py:617 DRS API error in region us-east-1: An error occurred (UnrecognizedClientException) when calling the DescribeSourceServers operation: The security token included in the request is invalid.
INFO     shared.inventory_query:inventory_query.py:621 Fallback complete: Retrieved 0 servers total, inventory updated
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
INFO     shared.inventory_query:inventory_query.py:227 Inventory is stale, falling back to DRS API and updating database
INFO     shared.inventory_query:inventory_query.py:578 Falling back to DRS API for 1 regions and updating inventory
WARNING  shared.inventory_query:inventory_query.py:94 Failed to publish CloudWatch metric InventoryDatabaseMisses: An error occurred (InvalidClientTokenId) when calling the PutMetricData operation: The security token included in the request is invalid.
ERROR    shared.inventory_query:inventory_query.py:617 DRS API error in region us-east-1: An error occurred (UnrecognizedClientException) when calling the DescribeSourceServers operation: The security token included in the request is invalid.
INFO     shared.inventory_query:inventory_query.py:621 Fallback complete: Retrieved 0 servers total, inventory updated
________________ test_property_13_topology_preserved_on_update _________________

    @settings(max_examples=100, deadline=None)
>   @given(existing_record=inventory_record(with_topology=True), new_server_data=source_server_data())

tests/unit/test_inventory_fallback_property.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

existing_record = {'hostname': '0', 'lastUpdated': '2026-02-21T04:45:28.974024+00:00', 'originalAccountId': '000000000000', 'originalReplicationConfigTemplateId': 'rct-000000', ...}
new_server_data = {'arn': 'arn:aws:drs:us-east-1:123456789012:source-server/s-00000000000000000', 'dataReplicationInfo': {'dataReplicationState': 'CONTINUOUS'}, 'hostname': '0', 'lifeCycle': {'state': 'READY_FOR_LAUNCH'}, ...}

    @settings(max_examples=100, deadline=None)
    @given(existing_record=inventory_record(with_topology=True), new_server_data=source_server_data())
    def test_property_13_topology_preserved_on_update(existing_record, new_server_data):
        """
        Feature: active-region-filtering
        Property 13: Failback Topology Preservation
    
        When updating an existing server record during inventory sync, the original
        topology fields (originalSourceRegion, originalAccountId, originalReplicationConfigTemplateId)
        should be preserved from the existing record.
    
        Validates: Requirements 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9
        """
        # Make server IDs match
        new_server_data["sourceServerID"] = existing_record["sourceServerID"]
    
        with patch("shared.inventory_query.get_inventory_table") as mock_table:
            # Setup: Mock DynamoDB table
            mock_dynamodb_table = MagicMock()
            mock_table.return_value = mock_dynamodb_table
    
            # Setup: Mock get_item to return existing record with topology
            mock_dynamodb_table.get_item.return_value = {"Item": existing_record}
    
            # Execute: Call _update_inventory_with_topology_preservation
            inventory_query._update_inventory_with_topology_preservation(
                new_server_data, existing_record["region"]
            )
    
            # Verify: put_item was called
>           assert mock_dynamodb_table.put_item.called, "Should update inventory record"
E           AssertionError: Should update inventory record
E           assert False
E            +  where False = <MagicMock name='get_inventory_table().put_item' id='5068604192'>.called
E            +    where <MagicMock name='get_inventory_table().put_item' id='5068604192'> = <MagicMock name='get_inventory_table()' id='4826295104'>.put_item
E           Falsifying example: test_property_13_topology_preserved_on_update(
E               existing_record={'sourceServerID': 's-00000000000000000',
E                'region': 'us-east-1',
E                'hostname': '0',
E                'replicationState': 'CONTINUOUS',
E                'lastUpdated': '2026-02-21T04:45:28.974024+00:00',
E                'originalSourceRegion': 'us-east-1',
E                'originalAccountId': '000000000000',
E                'originalReplicationConfigTemplateId': 'rct-000000',
E                'topologyLastUpdated': '2026-02-21T04:45:28.974166+00:00'},
E               new_server_data={'sourceServerID': 's-00000000000000000',
E                'hostname': '0',
E                'arn': 'arn:aws:drs:us-east-1:123456789012:source-server/s-00000000000000000',
E                'tags': {},
E                'dataReplicationInfo': {'dataReplicationState': 'CONTINUOUS'},
E                'lifeCycle': {'state': 'READY_FOR_LAUNCH'},
E                'sourceProperties': {'cpus': [{'cores': 1}],
E                 'ram': 1024,
E                 'disks': [],
E                 'identificationHints': {'awsInstanceID': 'arn:aws:ec2:us-east-1:123456789012:instance/i-00000000000000000'}}},
E           )

tests/unit/test_inventory_fallback_property.py:273: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:548 DynamoDB error updating inventory with topology preservation: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.
ERROR    shared.inventory_query:inventory_query.py:548 DynamoDB error updating inventory with topology preservation: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.
______________ test_property_13_topology_captured_for_new_server _______________

    @settings(max_examples=100, deadline=None)
>   @given(new_server_data=source_server_data(), region=st.sampled_from(DRS_REGIONS))

tests/unit/test_inventory_fallback_property.py:298: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

new_server_data = {'arn': 'arn:aws:drs:us-east-1:123456789012:source-server/s-00000000000000000', 'dataReplicationInfo': {'dataReplicationState': 'CONTINUOUS'}, 'hostname': '0', 'lifeCycle': {'state': 'READY_FOR_LAUNCH'}, ...}
region = 'us-east-1'

    @settings(max_examples=100, deadline=None)
    @given(new_server_data=source_server_data(), region=st.sampled_from(DRS_REGIONS))
    def test_property_13_topology_captured_for_new_server(new_server_data, region):
        """
        Feature: active-region-filtering
        Property 13: Failback Topology Preservation
    
        When adding a new server to inventory (no existing record), the current
        region and account should be captured as the original topology.
    
        Validates: Requirements 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9
        """
        with patch("shared.inventory_query.get_inventory_table") as mock_table:
            # Setup: Mock DynamoDB table
            mock_dynamodb_table = MagicMock()
            mock_table.return_value = mock_dynamodb_table
    
            # Setup: Mock get_item to return no existing record
            mock_dynamodb_table.get_item.return_value = {}
    
            # Execute: Call _update_inventory_with_topology_preservation
            account_id = "123456789012"
            inventory_query._update_inventory_with_topology_preservation(new_server_data, region)
    
            # Verify: put_item was called
>           assert mock_dynamodb_table.put_item.called, "Should create inventory record"
E           AssertionError: Should create inventory record
E           assert False
E            +  where False = <MagicMock name='get_inventory_table().put_item' id='5023312464'>.called
E            +    where <MagicMock name='get_inventory_table().put_item' id='5023312464'> = <MagicMock name='get_inventory_table()' id='5038783904'>.put_item
E           Falsifying example: test_property_13_topology_captured_for_new_server(
E               new_server_data={'sourceServerID': 's-00000000000000000',
E                'hostname': '0',
E                'arn': 'arn:aws:drs:us-east-1:123456789012:source-server/s-00000000000000000',
E                'tags': {},
E                'dataReplicationInfo': {'dataReplicationState': 'CONTINUOUS'},
E                'lifeCycle': {'state': 'READY_FOR_LAUNCH'},
E                'sourceProperties': {'cpus': [{'cores': 1}],
E                 'ram': 1024,
E                 'disks': [],
E                 'identificationHints': {'awsInstanceID': 'arn:aws:ec2:us-east-1:123456789012:instance/i-00000000000000000'}}},
E               region='us-east-1',
E           )

tests/unit/test_inventory_fallback_property.py:322: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:548 DynamoDB error updating inventory with topology preservation: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.
ERROR    shared.inventory_query:inventory_query.py:548 DynamoDB error updating inventory with topology preservation: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.
_________ test_property_13_get_failback_topology_returns_correct_data __________

    @settings(max_examples=100, deadline=None)
>   @given(record=inventory_record(with_topology=True))

tests/unit/test_inventory_fallback_property.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

record = {'hostname': '0', 'lastUpdated': '2026-02-21T04:45:29.305783+00:00', 'originalAccountId': '000000000000', 'originalReplicationConfigTemplateId': 'rct-000000', ...}

    @settings(max_examples=100, deadline=None)
    @given(record=inventory_record(with_topology=True))
    def test_property_13_get_failback_topology_returns_correct_data(record):
        """
        Feature: active-region-filtering
        Property 13: Failback Topology Preservation
    
        The get_failback_topology function should return the original topology
        fields from the inventory record for use in failback operations.
    
        Validates: Requirements 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9
        """
        with patch("shared.inventory_query.get_inventory_table") as mock_table:
            # Setup: Mock DynamoDB table
            mock_dynamodb_table = MagicMock()
            mock_table.return_value = mock_dynamodb_table
    
            # Setup: Mock get_item to return record with topology
            mock_dynamodb_table.get_item.return_value = {"Item": record}
    
            # Execute: Call get_failback_topology
            result = inventory_query.get_failback_topology(record["sourceServerID"], record["region"])
    
            # Verify: Result contains original topology fields
>           assert result["originalSourceRegion"] == record["originalSourceRegion"], (
                f"Should return originalSourceRegion: {record['originalSourceRegion']}, " f"got {result.get('originalSourceRegion')}"
            )
E           TypeError: 'NoneType' object is not subscriptable
E           Falsifying example: test_property_13_get_failback_topology_returns_correct_data(
E               record={'sourceServerID': 's-00000000000000000',
E                'region': 'us-east-1',
E                'hostname': '0',
E                'replicationState': 'CONTINUOUS',
E                'lastUpdated': '2026-02-21T04:45:29.305783+00:00',
E                'originalSourceRegion': 'us-east-1',
E                'originalAccountId': '000000000000',
E                'originalReplicationConfigTemplateId': 'rct-000000',
E                'topologyLastUpdated': '2026-02-21T04:45:29.305923+00:00'},
E           )

tests/unit/test_inventory_fallback_property.py:363: TypeError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:464 DynamoDB error retrieving failback topology: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.
ERROR    shared.inventory_query:inventory_query.py:464 DynamoDB error retrieving failback topology: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.
___________________ test_property_inventory_freshness_check ____________________

    @given(age_minutes=st.integers(min_value=0, max_value=60))
>   @settings(max_examples=100)

tests/unit/test_inventory_query_property.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

age_minutes = 0

    @given(age_minutes=st.integers(min_value=0, max_value=60))
    @settings(max_examples=100)
    def test_property_inventory_freshness_check(age_minutes):
        """
        **Validates: Requirements 12.3, 12.4, 12.8**
    
        Property 4: Inventory Database Freshness Check
    
        For any operation that can use inventory data, when the inventory database
        contains data updated within the last 15 minutes, the operation should use
        the inventory database instead of making DRS API calls, and when the
        inventory is stale or unavailable, should fall back to DRS API calls.
        """
        # Generate timestamp based on age
        timestamp = (
            datetime.now(timezone.utc) - timedelta(minutes=age_minutes)
        ).isoformat()
    
        # Mock DynamoDB table
        mock_table = Mock()
        mock_table.scan.return_value = {
            "Items": [{"sourceServerID": "s-test", "lastUpdated": timestamp}]
        }
    
        with patch(
            "shared.inventory_query.get_inventory_table", return_value=mock_table
        ):
            result = is_inventory_fresh(max_age_minutes=15)
    
            # Verify: Fresh if age < 15 minutes, stale otherwise
            if age_minutes < 15:
>               assert result is True, (
                    f"Inventory aged {age_minutes} minutes should be fresh "
                    f"(threshold: 15 minutes)"
                )
E               AssertionError: Inventory aged 0 minutes should be fresh (threshold: 15 minutes)
E               assert False is True
E               Falsifying example: test_property_inventory_freshness_check(
E                   age_minutes=0,
E               )

tests/unit/test_inventory_query_property.py:66: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
___________________ test_property_custom_freshness_threshold ___________________

    @given(
>       age_minutes=st.integers(min_value=0, max_value=60),
        threshold_minutes=st.integers(min_value=1, max_value=30),
    )

tests/unit/test_inventory_query_property.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

age_minutes = 0, threshold_minutes = 1

    @given(
        age_minutes=st.integers(min_value=0, max_value=60),
        threshold_minutes=st.integers(min_value=1, max_value=30),
    )
    @settings(max_examples=100)
    def test_property_custom_freshness_threshold(age_minutes, threshold_minutes):
        """
        **Validates: Requirements 12.3, 12.4**
    
        Property 4 (Extended): Custom Freshness Threshold
    
        For any custom freshness threshold, inventory should be considered fresh
        if age < threshold, and stale if age >= threshold.
        """
        # Generate timestamp based on age
        timestamp = (
            datetime.now(timezone.utc) - timedelta(minutes=age_minutes)
        ).isoformat()
    
        # Mock DynamoDB table
        mock_table = Mock()
        mock_table.scan.return_value = {
            "Items": [{"sourceServerID": "s-test", "lastUpdated": timestamp}]
        }
    
        with patch(
            "shared.inventory_query.get_inventory_table", return_value=mock_table
        ):
            result = is_inventory_fresh(max_age_minutes=threshold_minutes)
    
            # Verify: Fresh if age < threshold, stale otherwise
            if age_minutes < threshold_minutes:
>               assert result is True, (
                    f"Inventory aged {age_minutes} minutes should be fresh "
                    f"with threshold {threshold_minutes} minutes"
                )
E               AssertionError: Inventory aged 0 minutes should be fresh with threshold 1 minutes
E               assert False is True
E               Falsifying example: test_property_custom_freshness_threshold(
E                   age_minutes=0,
E                   threshold_minutes=1,
E               )

tests/unit/test_inventory_query_property.py:109: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
_________________ test_property_stale_inventory_returns_empty __________________

    @given(is_fresh=st.booleans())
>   @settings(max_examples=100)

tests/unit/test_inventory_query_property.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

is_fresh = True

    @given(is_fresh=st.booleans())
    @settings(max_examples=100)
    def test_property_stale_inventory_returns_empty(is_fresh):
        """
        **Validates: Requirements 12.4, 12.8**
    
        Property 4 (Extended): Stale Inventory Fallback
    
        For any query operation, when inventory is stale, the operation should
        return empty list to trigger DRS API fallback.
        """
        # Generate fresh or stale timestamp
        if is_fresh:
            age_minutes = 5  # Fresh
        else:
            age_minutes = 20  # Stale
    
        timestamp = (
            datetime.now(timezone.utc) - timedelta(minutes=age_minutes)
        ).isoformat()
    
        # Mock DynamoDB table
        mock_table = Mock()
        mock_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-test", "lastUpdated": timestamp}]},
            {
                "Items": [
                    {
                        "sourceServerID": "s-test",
                        "replicationRegion": "us-east-1",
                        "hostname": "server1",
                    }
                ]
            },
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table", return_value=mock_table
        ):
            servers = query_inventory_by_regions(["us-east-1"])
    
            # Verify: Returns servers if fresh, empty list if stale
            if is_fresh:
>               assert len(servers) > 0, "Fresh inventory should return servers"
E               AssertionError: Fresh inventory should return servers
E               assert 0 > 0
E                +  where 0 = len([])
E               Falsifying example: test_property_stale_inventory_returns_empty(
E                   is_fresh=True,
E               )

tests/unit/test_inventory_query_property.py:163: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
__________________ test_property_inventory_data_completeness ___________________
  + Exception Group Traceback (most recent call last):
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/runner.py", line 341, in from_call
  |     result: TResult | None = func()
  |                              ^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/runner.py", line 242, in <lambda>
  |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_hooks.py", line 512, in __call__
  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_manager.py", line 120, in _hookexec
  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 167, in _multicall
  |     raise exception
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
  |     teardown.throw(exception)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/threadexception.py", line 92, in pytest_runtest_call
  |     yield from thread_exception_runtest_hook()
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/threadexception.py", line 68, in thread_exception_runtest_hook
  |     yield
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
  |     teardown.throw(exception)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/unraisableexception.py", line 95, in pytest_runtest_call
  |     yield from unraisable_exception_runtest_hook()
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/unraisableexception.py", line 70, in unraisable_exception_runtest_hook
  |     yield
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
  |     teardown.throw(exception)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/logging.py", line 846, in pytest_runtest_call
  |     yield from self._runtest_for(item, "call")
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/logging.py", line 829, in _runtest_for
  |     yield
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
  |     teardown.throw(exception)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/capture.py", line 880, in pytest_runtest_call
  |     return (yield)
  |             ^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
  |     teardown.throw(exception)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 53, in run_old_style_hookwrapper
  |     return result.get_result()
  |            ^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_result.py", line 103, in get_result
  |     raise exc.with_traceback(tb)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 38, in run_old_style_hookwrapper
  |     res = yield
  |           ^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
  |     teardown.throw(exception)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/skipping.py", line 257, in pytest_runtest_call
  |     return (yield)
  |             ^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 121, in _multicall
  |     res = hook_impl.function(*args)
  |           ^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/runner.py", line 174, in pytest_runtest_call
  |     item.runtest()
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/python.py", line 1627, in runtest
  |     self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_hooks.py", line 512, in __call__
  |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_manager.py", line 120, in _hookexec
  |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 167, in _multicall
  |     raise exception
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
  |     teardown.throw(exception)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 53, in run_old_style_hookwrapper
  |     return result.get_result()
  |            ^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_result.py", line 103, in get_result
  |     raise exc.with_traceback(tb)
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 38, in run_old_style_hookwrapper
  |     res = yield
  |           ^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/pluggy/_callers.py", line 121, in _multicall
  |     res = hook_impl.function(*args)
  |           ^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/_pytest/python.py", line 159, in pytest_pyfunc_call
  |     result = testfunction(**testargs)
  |              ^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_inventory_query_property.py", line 176, in test_property_inventory_data_completeness
  |     include_required_fields=st.booleans(),
  |                ^^^
  |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/.venv/lib/python3.12/site-packages/hypothesis/core.py", line 1787, in wrapped_test
  |     raise the_error_hypothesis_found
  | ExceptionGroup: Hypothesis found 2 distinct failures. (2 sub-exceptions)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_inventory_query_property.py", line 224, in test_property_inventory_data_completeness
    |     assert len(servers) == 1
    | AssertionError: assert 0 == 1
    |  +  where 0 = len([])
    | Falsifying example: test_property_inventory_data_completeness(
    |     include_required_fields=True,
    |     region='us-east-1',
    | )
    +---------------- 2 ----------------
    | Traceback (most recent call last):
    |   File "/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_inventory_query_property.py", line 235, in test_property_inventory_data_completeness
    |     assert len(servers) == 1
    | AssertionError: assert 0 == 1
    |  +  where 0 = len([])
    | Falsifying example: test_property_inventory_data_completeness(
    |     include_required_fields=False,
    |     region='us-east-1',
    | )
    +------------------------------------
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
________________ test_property_all_servers_have_required_fields ________________

    @given(
>       server_count=st.integers(min_value=0, max_value=10),
        region=st.sampled_from(["us-east-1", "us-west-2", "eu-west-1"]),
    )

tests/unit/test_inventory_query_property.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

server_count = 1, region = 'us-east-1'

    @given(
        server_count=st.integers(min_value=0, max_value=10),
        region=st.sampled_from(["us-east-1", "us-west-2", "eu-west-1"]),
    )
    @settings(max_examples=100)
    def test_property_all_servers_have_required_fields(server_count, region):
        """
        **Validates: Requirements 4.3, 12.9**
    
        Property 9 (Extended): All Servers Have Required Fields
    
        For any list of servers retrieved from inventory, all servers should
        contain the required fields.
        """
        # Generate fresh timestamp
        timestamp = (datetime.now(timezone.utc) - timedelta(minutes=5)).isoformat()
    
        # Generate server records with all required fields
        servers = []
        for i in range(server_count):
            servers.append(
                {
                    "sourceServerID": f"s-{i:017x}",
                    "replicationRegion": region,
                    "replicationState": "CONTINUOUS",
                    "hostname": f"server-{i}",
                    "sourceAccountId": "123456789012",
                    "sourceTags": {"Index": str(i)},
                }
            )
    
        # Mock DynamoDB table
        mock_table = Mock()
        mock_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-test", "lastUpdated": timestamp}]},
            {"Items": servers},
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table", return_value=mock_table
        ):
            result_servers = query_inventory_by_regions([region])
    
            # Verify: All servers have required fields
>           assert len(result_servers) == server_count
E           assert 0 == 1
E            +  where 0 = len([])
E           Falsifying example: test_property_all_servers_have_required_fields(
E               server_count=1,
E               region='us-east-1',
E           )

tests/unit/test_inventory_query_property.py:282: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
____________ TestIsInventoryFresh.test_fresh_inventory_returns_true ____________

self = <tests.unit.test_inventory_query_unit.TestIsInventoryFresh object at 0x10d7af080>
mock_dynamodb_table = <Mock id='4984793632'>
fresh_timestamp = '2026-02-21T04:40:39.449820+00:00'

    def test_fresh_inventory_returns_true(
        self, mock_dynamodb_table, fresh_timestamp
    ):
        """Test that fresh inventory (< 15 minutes) returns True."""
        mock_dynamodb_table.scan.return_value = {
            "Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]
        }
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            result = is_inventory_fresh()
    
>       assert result is True
E       assert False is True

tests/unit/test_inventory_query_unit.py:69: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
___________________ TestIsInventoryFresh.test_custom_max_age ___________________

self = <tests.unit.test_inventory_query_unit.TestIsInventoryFresh object at 0x10d7cc200>
mock_dynamodb_table = <Mock id='5036807744'>

    def test_custom_max_age(self, mock_dynamodb_table):
        """Test custom max_age_minutes parameter."""
        # Timestamp 10 minutes ago
        timestamp = (datetime.now(timezone.utc) - timedelta(minutes=10)).isoformat()
        mock_dynamodb_table.scan.return_value = {
            "Items": [{"sourceServerID": "s-123", "lastUpdated": timestamp}]
        }
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            # Fresh with 15 minute threshold
>           assert is_inventory_fresh(max_age_minutes=15) is True
E           assert False is True
E            +  where False = is_inventory_fresh(max_age_minutes=15)

tests/unit/test_inventory_query_unit.py:150: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
_____________ TestQueryInventoryByRegions.test_query_single_region _____________

self = <tests.unit.test_inventory_query_unit.TestQueryInventoryByRegions object at 0x10d7cc6e0>
mock_dynamodb_table = <Mock id='5036805488'>
fresh_timestamp = '2026-02-21T04:40:39.737797+00:00'

    def test_query_single_region(self, mock_dynamodb_table, fresh_timestamp):
        """Test querying a single region."""
        mock_dynamodb_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]},
            {
                "Items": [
                    {
                        "sourceServerID": "s-123",
                        "replicationRegion": "us-east-1",
                        "hostname": "server1",
                    }
                ]
            },
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            servers = query_inventory_by_regions(["us-east-1"])
    
>       assert len(servers) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/unit/test_inventory_query_unit.py:180: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
___________ TestQueryInventoryByRegions.test_query_multiple_regions ____________

self = <tests.unit.test_inventory_query_unit.TestQueryInventoryByRegions object at 0x10d7cc9e0>
mock_dynamodb_table = <Mock id='5036802800'>
fresh_timestamp = '2026-02-21T04:40:39.789281+00:00'

    def test_query_multiple_regions(self, mock_dynamodb_table, fresh_timestamp):
        """Test querying multiple regions."""
        mock_dynamodb_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]},
            {
                "Items": [
                    {
                        "sourceServerID": "s-123",
                        "replicationRegion": "us-east-1",
                    },
                    {
                        "sourceServerID": "s-456",
                        "replicationRegion": "us-west-2",
                    },
                ]
            },
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            servers = query_inventory_by_regions(["us-east-1", "us-west-2"])
    
>       assert len(servers) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/unit/test_inventory_query_unit.py:208: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
_________ TestQueryInventoryByRegions.test_query_with_hostname_filter __________

self = <tests.unit.test_inventory_query_unit.TestQueryInventoryByRegions object at 0x10d7ccce0>
mock_dynamodb_table = <Mock id='5036815520'>
fresh_timestamp = '2026-02-21T04:40:39.826418+00:00'

    def test_query_with_hostname_filter(
        self, mock_dynamodb_table, fresh_timestamp
    ):
        """Test querying with hostname filter."""
        mock_dynamodb_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]},
            {
                "Items": [
                    {
                        "sourceServerID": "s-123",
                        "hostname": "web-server-01",
                    }
                ]
            },
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            servers = query_inventory_by_regions(
                ["us-east-1"], filters={"hostname": "web-server-01"}
            )
    
>       assert len(servers) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/unit/test_inventory_query_unit.py:234: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
_____ TestQueryInventoryByRegions.test_query_with_replication_state_filter _____

self = <tests.unit.test_inventory_query_unit.TestQueryInventoryByRegions object at 0x10d7ccfe0>
mock_dynamodb_table = <Mock id='5036804624'>
fresh_timestamp = '2026-02-21T04:40:39.866229+00:00'

    def test_query_with_replication_state_filter(
        self, mock_dynamodb_table, fresh_timestamp
    ):
        """Test querying with replicationState filter."""
        mock_dynamodb_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]},
            {
                "Items": [
                    {
                        "sourceServerID": "s-123",
                        "replicationState": "CONTINUOUS",
                    }
                ]
            },
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            servers = query_inventory_by_regions(
                ["us-east-1"], filters={"replicationState": "CONTINUOUS"}
            )
    
>       assert len(servers) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/unit/test_inventory_query_unit.py:261: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
____________ TestQueryInventoryByRegions.test_query_with_pagination ____________

self = <tests.unit.test_inventory_query_unit.TestQueryInventoryByRegions object at 0x10d7af470>
mock_dynamodb_table = <Mock id='5036806592'>
fresh_timestamp = '2026-02-21T04:40:39.905512+00:00'

    def test_query_with_pagination(self, mock_dynamodb_table, fresh_timestamp):
        """Test querying with DynamoDB pagination."""
        mock_dynamodb_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]},
            {
                "Items": [{"sourceServerID": "s-123"}],
                "LastEvaluatedKey": {"sourceServerID": "s-123"},
            },
            {"Items": [{"sourceServerID": "s-456"}]},
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            servers = query_inventory_by_regions(["us-east-1"])
    
>       assert len(servers) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/unit/test_inventory_query_unit.py:281: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:230 Inventory is stale, returning empty list for DRS API fallback
________ TestQueryInventoryByStagingAccount.test_query_staging_account _________

self = <tests.unit.test_inventory_query_unit.TestQueryInventoryByStagingAccount object at 0x10d7cd9a0>
mock_dynamodb_table = <Mock id='4984797712'>
fresh_timestamp = '2026-02-21T04:40:40.070662+00:00'

    def test_query_staging_account(self, mock_dynamodb_table, fresh_timestamp):
        """Test querying by staging account ID."""
        mock_dynamodb_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]},
            {
                "Items": [
                    {
                        "sourceServerID": "s-123",
                        "stagingAccountId": "123456789012",
                    }
                ]
            },
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            servers = query_inventory_by_staging_account("123456789012")
    
>       assert len(servers) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/unit/test_inventory_query_unit.py:349: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:315 Inventory is stale, returning empty list for DRS API fallback
__ TestQueryInventoryByStagingAccount.test_query_staging_account_with_regions __

self = <tests.unit.test_inventory_query_unit.TestQueryInventoryByStagingAccount object at 0x10d7cdca0>
mock_dynamodb_table = <Mock id='4984787536'>
fresh_timestamp = '2026-02-21T04:40:40.116637+00:00'

    def test_query_staging_account_with_regions(
        self, mock_dynamodb_table, fresh_timestamp
    ):
        """Test querying staging account with region filter."""
        mock_dynamodb_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]},
            {
                "Items": [
                    {
                        "sourceServerID": "s-123",
                        "stagingAccountId": "123456789012",
                        "replicationRegion": "us-east-1",
                    }
                ]
            },
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            servers = query_inventory_by_staging_account(
                "123456789012", regions=["us-east-1"]
            )
    
>       assert len(servers) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/unit/test_inventory_query_unit.py:377: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:315 Inventory is stale, returning empty list for DRS API fallback
________________ TestGetServerById.test_get_server_with_region _________________

self = <tests.unit.test_inventory_query_unit.TestGetServerById object at 0x10d7ce120>
mock_dynamodb_table = <Mock id='4984793008'>
fresh_timestamp = '2026-02-21T04:40:40.157794+00:00'

    def test_get_server_with_region(self, mock_dynamodb_table, fresh_timestamp):
        """Test getting server with replication region (direct lookup)."""
        mock_dynamodb_table.scan.return_value = {
            "Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]
        }
        mock_dynamodb_table.get_item.return_value = {
            "Item": {
                "sourceServerID": "s-123",
                "replicationRegion": "us-east-1",
                "hostname": "server1",
            }
        }
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            server = get_server_by_id("s-123", "us-east-1")
    
>       assert server is not None
E       assert None is not None

tests/unit/test_inventory_query_unit.py:402: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:378 Inventory is stale, returning None for DRS API fallback
_______________ TestGetServerById.test_get_server_without_region _______________

self = <tests.unit.test_inventory_query_unit.TestGetServerById object at 0x10d7ce420>
mock_dynamodb_table = <Mock id='4984785184'>
fresh_timestamp = '2026-02-21T04:40:40.201393+00:00'

    def test_get_server_without_region(
        self, mock_dynamodb_table, fresh_timestamp
    ):
        """Test getting server without region (scan lookup)."""
        mock_dynamodb_table.scan.side_effect = [
            {"Items": [{"sourceServerID": "s-123", "lastUpdated": fresh_timestamp}]},
            {
                "Items": [
                    {
                        "sourceServerID": "s-123",
                        "hostname": "server1",
                    }
                ]
            },
        ]
    
        with patch(
            "shared.inventory_query.get_inventory_table",
            return_value=mock_dynamodb_table,
        ):
            server = get_server_by_id("s-123")
    
>       assert server is not None
E       assert None is not None

tests/unit/test_inventory_query_unit.py:428: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.inventory_query:inventory_query.py:378 Inventory is stale, returning None for DRS API fallback
__________________ test_property_region_status_table_updates ___________________

    @settings(max_examples=100)
>   @given(scan_results=st.lists(region_scan_result_strategy(), min_size=1, max_size=28, unique_by=lambda x: x["region"]))

tests/unit/test_inventory_sync_property.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scan_results = [{'errorMessage': None, 'region': 'us-east-1', 'serverCount': 0, 'servers': [], ...}]

    @settings(max_examples=100)
    @given(scan_results=st.lists(region_scan_result_strategy(), min_size=1, max_size=28, unique_by=lambda x: x["region"]))
    @pytest.mark.property
    def test_property_region_status_table_updates(scan_results):
        """
        Property 3: Region Status Table Updates.
    
        Feature: active-region-filtering
        Property 3: For any source server inventory sync operation, when scanning
                    a region, the operation should update the region status table
                    with the current server count for that region, and if the scan
                    fails, should record the error message in the table.
    
        **Validates: Requirements 5.1, 5.3, 5.4, 5.5**
        """
        # Arrange: Create mock region status table
        mock_table = MagicMock()
    
        # Track all put_item calls
        put_item_calls = []
    
        def capture_put_item(Item):
            put_item_calls.append(Item)
            return {}
    
        mock_table.put_item.side_effect = capture_put_item
    
        # Patch get_region_status_table to return our mock
        with patch("shared.active_region_filter.get_region_status_table", return_value=mock_table):
            # Act: Update region status for each scan result
            for result in scan_results:
                update_region_status(
                    region=result["region"],
                    server_count=result["serverCount"],
                    error_message=result["errorMessage"],
                )
    
        # Assert: Each region should have been updated
>       assert len(put_item_calls) == len(scan_results), (
            f"Expected {len(scan_results)} region status updates, " f"got {len(put_item_calls)}"
        )
E       AssertionError: Expected 1 region status updates, got 0
E       assert 0 == 1
E        +  where 0 = len([])
E        +  and   1 = len([{'errorMessage': None, 'region': 'us-east-1', 'serverCount': 0, 'servers': [], ...}])
E       Falsifying example: test_property_region_status_table_updates(
E           scan_results=[{'region': 'us-east-1',
E             'servers': [],
E             'status': 'NOT_INITIALIZED',
E             'serverCount': 0,
E             'errorMessage': None}],
E       )

tests/unit/test_inventory_sync_property.py:138: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
________________ test_property_region_status_update_idempotency ________________

    @settings(max_examples=50)
>   @given(
        region=st.sampled_from(DRS_REGIONS),
        server_count=st.integers(min_value=0, max_value=1000),
        error_message=st.one_of(st.none(), st.text(min_size=1, max_size=500)),
    )

tests/unit/test_inventory_sync_property.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

region = 'us-east-1', server_count = 0, error_message = None

    @settings(max_examples=50)
    @given(
        region=st.sampled_from(DRS_REGIONS),
        server_count=st.integers(min_value=0, max_value=1000),
        error_message=st.one_of(st.none(), st.text(min_size=1, max_size=500)),
    )
    @pytest.mark.property
    def test_property_region_status_update_idempotency(region, server_count, error_message):
        """
        Property 3 (supplemental): Region status updates are idempotent.
    
        Tests that calling update_region_status multiple times with the same
        data produces consistent results (last write wins).
    
        **Validates: Requirements 5.1, 5.3**
        """
        # Arrange: Create mock region status table
        mock_table = MagicMock()
        put_item_calls = []
    
        def capture_put_item(Item):
            put_item_calls.append(Item)
            return {}
    
        mock_table.put_item.side_effect = capture_put_item
    
        # Patch get_region_status_table to return our mock
        with patch("shared.active_region_filter.get_region_status_table", return_value=mock_table):
            # Act: Update region status multiple times with same data
            for _ in range(3):
                update_region_status(region=region, server_count=server_count, error_message=error_message)
    
        # Assert: All updates should have been called
>       assert len(put_item_calls) == 3, f"Expected 3 updates, got {len(put_item_calls)}"
E       AssertionError: Expected 3 updates, got 0
E       assert 0 == 3
E        +  where 0 = len([])
E       Falsifying example: test_property_region_status_update_idempotency(
E           region='us-east-1',
E           server_count=0,
E           error_message=None,
E       )

tests/unit/test_inventory_sync_property.py:232: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
____________ test_property_region_status_update_overwrites_previous ____________

    @settings(max_examples=50)
>   @given(
        region=st.sampled_from(DRS_REGIONS),
        initial_count=st.integers(min_value=0, max_value=100),
        updated_count=st.integers(min_value=0, max_value=100),
    )

tests/unit/test_inventory_sync_property.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

region = 'us-east-1', initial_count = 0, updated_count = 0

    @settings(max_examples=50)
    @given(
        region=st.sampled_from(DRS_REGIONS),
        initial_count=st.integers(min_value=0, max_value=100),
        updated_count=st.integers(min_value=0, max_value=100),
    )
    @pytest.mark.property
    def test_property_region_status_update_overwrites_previous(region, initial_count, updated_count):
        """
        Property 3 (supplemental): Region status updates overwrite previous values.
    
        Tests that updating region status with new server count correctly
        overwrites the previous value (last write wins).
    
        **Validates: Requirements 5.1, 5.3**
        """
        # Arrange: Create mock region status table
        mock_table = MagicMock()
        put_item_calls = []
    
        def capture_put_item(Item):
            put_item_calls.append(Item)
            return {}
    
        mock_table.put_item.side_effect = capture_put_item
    
        # Patch get_region_status_table to return our mock
        with patch("shared.active_region_filter.get_region_status_table", return_value=mock_table):
            # Act: Update with initial count
            update_region_status(region=region, server_count=initial_count, error_message=None)
    
            # Act: Update with new count (should overwrite)
            update_region_status(region=region, server_count=updated_count, error_message=None)
    
        # Assert: Both updates should have been called
>       assert len(put_item_calls) == 2, f"Expected 2 updates, got {len(put_item_calls)}"
E       AssertionError: Expected 2 updates, got 0
E       assert 0 == 2
E        +  where 0 = len([])
E       Falsifying example: test_property_region_status_update_overwrites_previous(
E           region='us-east-1',
E           initial_count=0,
E           updated_count=0,
E       )

tests/unit/test_inventory_sync_property.py:279: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
_________________ test_region_status_update_specific_examples __________________

    @pytest.mark.property
    def test_region_status_update_specific_examples():
        """Unit test examples for region status updates."""
        # Arrange: Create mock table
        mock_table = MagicMock()
        put_item_calls = []
    
        def capture_put_item(Item):
            put_item_calls.append(Item)
            return {}
    
        mock_table.put_item.side_effect = capture_put_item
    
        # Patch get_region_status_table
        with patch("shared.active_region_filter.get_region_status_table", return_value=mock_table):
            # Example 1: Region with servers (AVAILABLE)
            update_region_status(region="us-east-1", server_count=42, error_message=None)
    
            # Example 2: Region with no servers (UNINITIALIZED)
            update_region_status(region="us-west-2", server_count=0, error_message=None)
    
            # Example 3: Region with error (ERROR)
            update_region_status(region="eu-west-1", server_count=0, error_message="DRS not initialized")
    
        # Assert: Three updates
>       assert len(put_item_calls) == 3
E       assert 0 == 3
E        +  where 0 = len([])

tests/unit/test_inventory_sync_property.py:516: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
WARNING  shared.active_region_filter:active_region_filter.py:63 DRS_REGION_STATUS_TABLE environment variable not set
WARNING  shared.active_region_filter:active_region_filter.py:239 Region status table not configured, skipping status update
_ TestProperty4ConfigurationStatusSchemaValidity.test_property_4_status_field_validity _

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': '0'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d5520>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:681: in test_property_4_status_field_validity
    retrieved_status = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_4_status_field_validity(
E               <tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d5520>,
E               group_id='0',
E               status='ready',
E               server_ids=['s-00000000000000000'],
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty4ConfigurationStatusSchemaValidity.test_property_4_timestamp_presence_for_configured_status _

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': '0'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d57c0>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:750: in test_property_4_timestamp_presence_for_configured_status
    retrieved_status = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_4_timestamp_presence_for_configured_status(
E               <tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d57c0>,
E               group_id='0',
E               status='ready',
E               server_ids=['s-00000000000000000'],
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty4ConfigurationStatusSchemaValidity.test_property_4_server_configs_structure_validity _

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': '0'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d5a60>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:827: in test_property_4_server_configs_structure_validity
    retrieved_status = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_4_server_configs_structure_validity(
E               <tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d5a60>,
E               group_id='0',
E               server_ids=['s-00000000000000000'],
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty4ConfigurationStatusSchemaValidity.test_property_4_not_configured_status_no_timestamp_required _

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': '0'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d5d00>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:902: in test_property_4_not_configured_status_no_timestamp_required
    retrieved_status = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_4_not_configured_status_no_timestamp_required(
E               <tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d5d00>,
E               group_id='0',
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty4ConfigurationStatusSchemaValidity.test_property_4_camelcase_naming_convention _

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': '0'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d5fa0>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:972: in test_property_4_camelcase_naming_convention
    retrieved_status = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = '0'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_4_camelcase_naming_convention(
E               <tests.unit.test_launch_config_service_property.TestProperty4ConfigurationStatusSchemaValidity object at 0x10d8d5fa0>,
E               group_id='0',
E               status='ready',
E               num_servers=1,
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty8ConfigurationDriftDetection.test_property_8_no_drift_when_hashes_match _

args = (<tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6660>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6660>
mock_get_status = <MagicMock name='get_config_status' id='5068259936'>
group_id = '0', server_ids = ['s-00000000000000000']
config_values = [{'instanceType': 't3.medium'}]

    @given(
        group_id=st.text(min_size=1, max_size=50),
        server_ids=st.lists(
            server_id_strategy(),
            min_size=1,
            max_size=10,
            unique=True
        ),
        config_values=st.lists(
            st.dictionaries(
                keys=st.sampled_from([
                    "instanceType",
                    "copyPrivateIp",
                    "copyTags"
                ]),
                values=st.one_of(
                    st.sampled_from(["t3.medium", "t3.large"]),
                    st.booleans()
                ),
                min_size=1,
                max_size=3
            ),
            min_size=1,
            max_size=10
        )
    )
    @patch("shared.launch_config_service.get_config_status")
    def test_property_8_no_drift_when_hashes_match(
        self,
        mock_get_status,
        group_id,
        server_ids,
        config_values
    ):
        """
        Feature: launch-config-preapplication, Property 8:
        For any wave execution, if current config hash matches stored hash,
        no drift should be detected.
    
        Validates: Requirements 4.4
        """
        # Ensure we have enough configs for all servers
        while len(config_values) < len(server_ids):
            config_values.append(config_values[0])
    
        # Create current configs for all servers
        current_configs = {
            server_id: config_values[i]
            for i, server_id in enumerate(server_ids)
        }
    
        # Create stored configs with SAME hashes
        stored_server_configs = {}
        for server_id, current_config in current_configs.items():
            # Calculate hash for current config
            current_hash = calculate_config_hash(current_config)
    
            stored_server_configs[server_id] = {
                "status": "ready",
                "configHash": current_hash,  # Same hash as current
                "lastApplied": "2025-02-16T10:00:00Z"
            }
    
        # Mock stored status
        mock_get_status.return_value = {
            "status": "ready",
            "serverConfigs": stored_server_configs
        }
    
        # Detect drift
        result = detect_config_drift(group_id, current_configs)
    
        # Property: NO drift should be detected when hashes match
>       assert result["hasDrift"] is False, (
            "No drift should be detected when current and stored hashes match"
        )
E       AssertionError: No drift should be detected when current and stored hashes match
E       assert True is False
E       Falsifying example: test_property_8_no_drift_when_hashes_match(
E           <tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6660>,
E           group_id='0',
E           server_ids=['s-00000000000000000'],
E           config_values=[{'instanceType': 't3.medium'}],
E       )

tests/unit/test_launch_config_service_property.py:1209: AssertionError
------------------------------ Captured log call -------------------------------
INFO     shared.launch_config_service:launch_config_service.py:735 Detecting config drift for group 0 with 1 current configs
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
WARNING  shared.launch_config_service:launch_config_service.py:742 Failed to get stored config status for 0: DynamoDB query failed: UnrecognizedClientException
INFO     shared.launch_config_service:launch_config_service.py:735 Detecting config drift for group 0 with 1 current configs
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
WARNING  shared.launch_config_service:launch_config_service.py:742 Failed to get stored config status for 0: DynamoDB query failed: UnrecognizedClientException
_ TestProperty8ConfigurationDriftDetection.test_property_8_partial_drift_detection _

args = (<tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6900>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6900>
mock_get_status = <MagicMock name='get_config_status' id='5036606576'>
group_id = '0', num_servers = 2, num_drifted = 1

    @given(
        group_id=st.text(min_size=1, max_size=50),
        num_servers=st.integers(min_value=2, max_value=10),
        num_drifted=st.integers(min_value=1, max_value=5)
    )
    @patch("shared.launch_config_service.get_config_status")
    def test_property_8_partial_drift_detection(
        self,
        mock_get_status,
        group_id,
        num_servers,
        num_drifted
    ):
        """
        Feature: launch-config-preapplication, Property 8:
        For any wave execution with mixed drift (some servers drifted,
        some not), drift detection must correctly identify only the
        drifted servers.
    
        Validates: Requirements 4.4
        """
        # Ensure num_drifted doesn't exceed num_servers
        num_drifted = min(num_drifted, num_servers)
    
        # Generate server IDs
        server_ids = [f"s-{'0' * 16}{i}" for i in range(num_servers)]
    
        # Create configs
        current_configs = {}
        stored_server_configs = {}
    
        for i, server_id in enumerate(server_ids):
            # Create current config
            current_config = {
                "instanceType": "t3.medium",
                "copyPrivateIp": True
            }
            current_configs[server_id] = current_config
            current_hash = calculate_config_hash(current_config)
    
            # First num_drifted servers have different stored hash
            if i < num_drifted:
                # Create different stored config
                stored_config = {
                    "instanceType": "t3.large",  # Different
                    "copyPrivateIp": True
                }
                stored_hash = calculate_config_hash(stored_config)
            else:
                # Same stored hash as current
                stored_hash = current_hash
    
            stored_server_configs[server_id] = {
                "status": "ready",
                "configHash": stored_hash,
                "lastApplied": "2025-02-16T10:00:00Z"
            }
    
        # Mock stored status
        mock_get_status.return_value = {
            "status": "ready",
            "serverConfigs": stored_server_configs
        }
    
        # Detect drift
        result = detect_config_drift(group_id, current_configs)
    
        # Property: Drift should be detected if any server has drifted
        assert result["hasDrift"] is True, (
            "Drift should be detected when some servers have drifted"
        )
    
        # Property: Exactly num_drifted servers should be in driftedServers
>       assert len(result["driftedServers"]) == num_drifted, (
            f"Expected {num_drifted} drifted servers, "
            f"but got {len(result['driftedServers'])}"
        )
E       AssertionError: Expected 1 drifted servers, but got 2
E       assert 2 == 1
E        +  where 2 = len(['s-00000000000000000', 's-00000000000000001'])
E       Falsifying example: test_property_8_partial_drift_detection(
E           <tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6900>,
E           group_id='0',
E           num_servers=2,
E           num_drifted=1,
E       )

tests/unit/test_launch_config_service_property.py:1297: AssertionError
------------------------------ Captured log call -------------------------------
INFO     shared.launch_config_service:launch_config_service.py:735 Detecting config drift for group 0 with 2 current configs
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
WARNING  shared.launch_config_service:launch_config_service.py:742 Failed to get stored config status for 0: DynamoDB query failed: UnrecognizedClientException
INFO     shared.launch_config_service:launch_config_service.py:735 Detecting config drift for group 0 with 2 current configs
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
WARNING  shared.launch_config_service:launch_config_service.py:742 Failed to get stored config status for 0: DynamoDB query failed: UnrecognizedClientException
_ TestProperty8ConfigurationDriftDetection.test_property_8_drift_with_missing_stored_config _

args = (<tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6ba0>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6ba0>
mock_get_status = <MagicMock name='get_config_status' id='5035925696'>
group_id = '0', server_ids = ['s-00000000000000000']

    @given(
        group_id=st.text(min_size=1, max_size=50),
        server_ids=st.lists(
            server_id_strategy(),
            min_size=1,
            max_size=8,
            unique=True
        )
    )
    @patch("shared.launch_config_service.get_config_status")
    def test_property_8_drift_with_missing_stored_config(
        self,
        mock_get_status,
        group_id,
        server_ids
    ):
        """
        Feature: launch-config-preapplication, Property 8:
        For any wave execution, if stored configuration is missing for
        a server, drift must be detected for that server.
    
        Validates: Requirements 4.4
        """
        # Create current configs for all servers
        current_configs = {
            server_id: {
                "instanceType": "t3.medium",
                "copyPrivateIp": True
            }
            for server_id in server_ids
        }
    
        # Mock stored status with NO server configs (empty)
        mock_get_status.return_value = {
            "status": "ready",
            "serverConfigs": {}  # No stored configs
        }
    
        # Detect drift
        result = detect_config_drift(group_id, current_configs)
    
        # Property: Drift MUST be detected when stored config is missing
        assert result["hasDrift"] is True, (
            "Drift should be detected when stored config is missing"
        )
    
        # Property: ALL servers should be drifted
        assert len(result["driftedServers"]) == len(server_ids), (
            f"All {len(server_ids)} servers should be drifted when "
            f"stored config is missing"
        )
    
        # Property: Each server should have drift details with None storedHash
        for server_id in server_ids:
            assert server_id in result["details"], (
                f"Server {server_id} should have drift details"
            )
    
            details = result["details"][server_id]
            assert details["storedHash"] is None, (
                f"Server {server_id} should have None storedHash when "
                f"stored config is missing"
            )
            assert details["currentHash"] is not None, (
                f"Server {server_id} should have currentHash"
            )
>           assert "no stored configuration" in details["reason"].lower(), (
                f"Server {server_id} reason should mention missing stored config"
            )
E           AssertionError: Server s-00000000000000000 reason should mention missing stored config
E           assert 'no stored configuration' in 'unable to retrieve stored configuration status'
E            +  where 'unable to retrieve stored configuration status' = <built-in method lower of str object at 0x10cc30f30>()
E            +    where <built-in method lower of str object at 0x10cc30f30> = 'Unable to retrieve stored configuration status'.lower
E           Falsifying example: test_property_8_drift_with_missing_stored_config(
E               <tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6ba0>,
E               group_id='0',
E               server_ids=['s-00000000000000000'],
E           )

tests/unit/test_launch_config_service_property.py:1382: AssertionError
------------------------------ Captured log call -------------------------------
INFO     shared.launch_config_service:launch_config_service.py:735 Detecting config drift for group 0 with 1 current configs
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
WARNING  shared.launch_config_service:launch_config_service.py:742 Failed to get stored config status for 0: DynamoDB query failed: UnrecognizedClientException
INFO     shared.launch_config_service:launch_config_service.py:735 Detecting config drift for group 0 with 1 current configs
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
WARNING  shared.launch_config_service:launch_config_service.py:742 Failed to get stored config status for 0: DynamoDB query failed: UnrecognizedClientException
_ TestProperty8ConfigurationDriftDetection.test_property_8_drift_with_not_configured_status _

args = (<tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6e40>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6e40>
mock_get_status = <MagicMock name='get_config_status' id='5085224144'>
group_id = '0', server_ids = ['s-00000000000000000']

    @given(
        group_id=st.text(min_size=1, max_size=50),
        server_ids=st.lists(
            server_id_strategy(),
            min_size=1,
            max_size=8,
            unique=True
        )
    )
    @patch("shared.launch_config_service.get_config_status")
    def test_property_8_drift_with_not_configured_status(
        self,
        mock_get_status,
        group_id,
        server_ids
    ):
        """
        Feature: launch-config-preapplication, Property 8:
        For any wave execution, if group has not_configured status,
        drift must be detected for all servers.
    
        Validates: Requirements 4.4
        """
        # Create current configs for all servers
        current_configs = {
            server_id: {
                "instanceType": "t3.medium",
                "copyPrivateIp": True
            }
            for server_id in server_ids
        }
    
        # Mock stored status as not_configured
        mock_get_status.return_value = {
            "status": "not_configured",
            "serverConfigs": {}
        }
    
        # Detect drift
        result = detect_config_drift(group_id, current_configs)
    
        # Property: Drift MUST be detected for not_configured status
        assert result["hasDrift"] is True, (
            "Drift should be detected when status is not_configured"
        )
    
        # Property: ALL servers should be drifted
        assert len(result["driftedServers"]) == len(server_ids), (
            f"All {len(server_ids)} servers should be drifted when "
            f"status is not_configured"
        )
    
        # Property: Each server should have drift details
        for server_id in server_ids:
            assert server_id in result["details"], (
                f"Server {server_id} should have drift details"
            )
    
            details = result["details"][server_id]
            assert details["storedHash"] is None, (
                f"Server {server_id} should have None storedHash"
            )
>           assert "no stored configuration status" in details["reason"].lower(), (
                f"Server {server_id} reason should mention not_configured status"
            )
E           AssertionError: Server s-00000000000000000 reason should mention not_configured status
E           assert 'no stored configuration status' in 'unable to retrieve stored configuration status'
E            +  where 'unable to retrieve stored configuration status' = <built-in method lower of str object at 0x10cc30f30>()
E            +    where <built-in method lower of str object at 0x10cc30f30> = 'Unable to retrieve stored configuration status'.lower
E           Falsifying example: test_property_8_drift_with_not_configured_status(
E               <tests.unit.test_launch_config_service_property.TestProperty8ConfigurationDriftDetection object at 0x10d8d6e40>,
E               group_id='0',
E               server_ids=['s-00000000000000000'],
E           )

tests/unit/test_launch_config_service_property.py:1448: AssertionError
------------------------------ Captured log call -------------------------------
INFO     shared.launch_config_service:launch_config_service.py:735 Detecting config drift for group 0 with 1 current configs
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
WARNING  shared.launch_config_service:launch_config_service.py:742 Failed to get stored config status for 0: DynamoDB query failed: UnrecognizedClientException
INFO     shared.launch_config_service:launch_config_service.py:735 Detecting config drift for group 0 with 1 current configs
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for 0: UnrecognizedClientException - The security token included in the request is invalid.
WARNING  shared.launch_config_service:launch_config_service.py:742 Failed to get stored config status for 0: DynamoDB query failed: UnrecognizedClientException
_ TestProperty6ReapplyOperationCompleteness.test_property_6_status_reflects_all_success _

args = (<tests.unit.test_launch_config_service_property.TestProperty6ReapplyOperationCompleteness object at 0x10d8d6a50>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.unit.test_launch_config_service_property.TestProperty6ReapplyOperationCompleteness object at 0x10d8d6a50>
mock_table = <MagicMock name='_get_protection_groups_table' id='4982809152'>
mock_boto3 = <MagicMock name='boto3' id='5049175600'>, group_id = '0'
region = 'us-east-1', server_ids = ['s-00000000000000000']

    @given(
        group_id=st.text(min_size=1, max_size=50),
        region=st.sampled_from(["us-east-1", "us-east-2", "us-west-2"]),
        server_ids=st.lists(
            server_id_strategy(),
            min_size=1,
            max_size=10,
            unique=True
        ),
    )
    @patch("shared.launch_config_service.boto3")
    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_property_6_status_reflects_all_success(
        self,
        mock_table,
        mock_boto3,
        group_id,
        region,
        server_ids
    ):
        """
        Feature: launch-config-preapplication, Property 6:
        For any manual re-apply where all servers succeed, the resulting
        status must be "ready".
    
        Validates: Requirements 3.3
        """
        # Create launch configs for all servers
        launch_configs = {
            server_id: {
                "instanceType": "t3.medium",
                "copyPrivateIp": True
            }
            for server_id in server_ids
        }
    
        # Mock DRS client to succeed for all servers
        mock_drs_client = MagicMock()
        mock_drs_client.update_launch_configuration.return_value = {}
        mock_boto3.client.return_value = mock_drs_client
    
        # Apply configurations
        result = apply_launch_configs_to_group(
            group_id=group_id,
            region=region,
            server_ids=server_ids,
            launch_configs=launch_configs
        )
    
        # Property: Status must be "ready" when all servers succeed
>       assert result["status"] == "ready", (
            f"Status should be 'ready' when all servers succeed, "
            f"but got '{result['status']}'"
        )
E       AssertionError: Status should be 'ready' when all servers succeed, but got 'failed'
E       assert 'failed' == 'ready'
E         
E         - ready
E         + failed
E       Falsifying example: test_property_6_status_reflects_all_success(
E           <tests.unit.test_launch_config_service_property.TestProperty6ReapplyOperationCompleteness object at 0x10d8d6a50>,
E           group_id='0',
E           region='us-east-1',
E           server_ids=['s-00000000000000000'],
E       )

tests/unit/test_launch_config_service_property.py:1866: AssertionError
------------------------------ Captured log call -------------------------------
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 1 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=1
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 1 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=1
_ TestProperty6ReapplyOperationCompleteness.test_property_6_status_reflects_partial_success _

args = (<tests.unit.test_launch_config_service_property.TestProperty6ReapplyOperationCompleteness object at 0x10d8d40e0>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.unit.test_launch_config_service_property.TestProperty6ReapplyOperationCompleteness object at 0x10d8d40e0>
mock_table = <MagicMock name='_get_protection_groups_table' id='5022412784'>
mock_boto3 = <MagicMock name='boto3' id='4982223120'>, group_id = '0'
region = 'us-east-1'
server_ids = ['s-00000000000000000', 's-00000000000000001']

    @given(
        group_id=st.text(min_size=1, max_size=50),
        region=st.sampled_from(["us-east-1", "us-east-2", "us-west-2"]),
        server_ids=st.lists(
            server_id_strategy(),
            min_size=2,
            max_size=10,
            unique=True
        ),
    )
    @patch("shared.launch_config_service.boto3")
    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_property_6_status_reflects_partial_success(
        self,
        mock_table,
        mock_boto3,
        group_id,
        region,
        server_ids
    ):
        """
        Feature: launch-config-preapplication, Property 6:
        For any manual re-apply where some servers succeed and some fail,
        the resulting status must be "partial".
    
        Validates: Requirements 3.3
        """
        # Create launch configs for all servers
        launch_configs = {
            server_id: {
                "instanceType": "t3.medium",
                "copyPrivateIp": True
            }
            for server_id in server_ids
        }
    
        # Mock DRS client to fail on every other server
        mock_drs_client = MagicMock()
    
        def side_effect(**kwargs):
            server_id = kwargs.get("sourceServerID")
            if server_ids.index(server_id) % 2 == 0:
                # Success
                return {}
            else:
                # Failure
                from botocore.exceptions import ClientError
                raise ClientError(
                    {
                        "Error": {
                            "Code": "ValidationException",
                            "Message": "Invalid config"
                        }
                    },
                    "update_launch_configuration"
                )
    
        mock_drs_client.update_launch_configuration.side_effect = side_effect
        mock_boto3.client.return_value = mock_drs_client
    
        # Apply configurations
        result = apply_launch_configs_to_group(
            group_id=group_id,
            region=region,
            server_ids=server_ids,
            launch_configs=launch_configs
        )
    
        # Property: Status must be "partial" when some succeed and some fail
>       assert result["status"] == "partial", (
            f"Status should be 'partial' when some servers succeed and "
            f"some fail, but got '{result['status']}'"
        )
E       AssertionError: Status should be 'partial' when some servers succeed and some fail, but got 'failed'
E       assert 'failed' == 'partial'
E         
E         - partial
E         + failed
E       Falsifying example: test_property_6_status_reflects_partial_success(
E           <tests.unit.test_launch_config_service_property.TestProperty6ReapplyOperationCompleteness object at 0x10d8d40e0>,
E           group_id='0',
E           region='us-east-1',
E           server_ids=['s-00000000000000000', 's-00000000000000001'],
E       )

tests/unit/test_launch_config_service_property.py:2040: AssertionError
------------------------------ Captured log call -------------------------------
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 2 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000001: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=2
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 2 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000001: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=2
_ TestProperty6ReapplyOperationCompleteness.test_property_6_reapply_updates_timestamps _

args = (<tests.unit.test_launch_config_service_property.TestProperty6ReapplyOperationCompleteness object at 0x10d8d7fb0>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.unit.test_launch_config_service_property.TestProperty6ReapplyOperationCompleteness object at 0x10d8d7fb0>
mock_table = <MagicMock name='_get_protection_groups_table' id='5023155168'>
mock_boto3 = <MagicMock name='boto3' id='5049185776'>, group_id = '0'
region = 'us-east-1', server_ids = ['s-00000000000000000']

    @given(
        group_id=st.text(min_size=1, max_size=50),
        region=st.sampled_from(["us-east-1", "us-east-2", "us-west-2"]),
        server_ids=st.lists(
            server_id_strategy(),
            min_size=1,
            max_size=8,
            unique=True
        ),
    )
    @patch("shared.launch_config_service.boto3")
    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_property_6_reapply_updates_timestamps(
        self,
        mock_table,
        mock_boto3,
        group_id,
        region,
        server_ids
    ):
        """
        Feature: launch-config-preapplication, Property 6:
        For any manual re-apply operation, the lastApplied timestamp
        must be updated for all processed servers.
    
        Validates: Requirements 3.2, 3.3
        """
        # Create launch configs for all servers
        launch_configs = {
            server_id: {
                "instanceType": "t3.medium",
                "copyPrivateIp": True
            }
            for server_id in server_ids
        }
    
        # Mock DRS client
        mock_drs_client = MagicMock()
        mock_boto3.client.return_value = mock_drs_client
    
        # Apply configurations
        result = apply_launch_configs_to_group(
            group_id=group_id,
            region=region,
            server_ids=server_ids,
            launch_configs=launch_configs
        )
    
        # Property: Each server must have lastApplied timestamp
        from datetime import datetime
        for server_id in server_ids:
            server_config = result["serverConfigs"][server_id]
            assert "lastApplied" in server_config, (
                f"Server {server_id} must have lastApplied timestamp"
            )
>           assert server_config["lastApplied"] is not None, (
                f"Server {server_id} lastApplied must not be None"
            )
E           AssertionError: Server s-00000000000000000 lastApplied must not be None
E           assert None is not None
E           Falsifying example: test_property_6_reapply_updates_timestamps(
E               <tests.unit.test_launch_config_service_property.TestProperty6ReapplyOperationCompleteness object at 0x10d8d7fb0>,
E               group_id='0',
E               region='us-east-1',
E               server_ids=['s-00000000000000000'],
E           )

tests/unit/test_launch_config_service_property.py:2200: AssertionError
------------------------------ Captured log call -------------------------------
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 1 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=1
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 1 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=1
_ TestProperty5ErrorVisibility.test_property_5_partial_failure_error_visibility _

args = (<tests.unit.test_launch_config_service_property.TestProperty5ErrorVisibility object at 0x10d8f1130>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.unit.test_launch_config_service_property.TestProperty5ErrorVisibility object at 0x10d8f1130>
mock_table = <MagicMock name='_get_protection_groups_table' id='5083800464'>
mock_boto3 = <MagicMock name='boto3' id='4985507136'>, group_id = '0'
region = 'us-east-1', num_servers = 2, num_failed = 1

    @given(
        group_id=st.text(min_size=1, max_size=50),
        region=st.sampled_from(["us-east-1", "us-east-2", "us-west-2"]),
        num_servers=st.integers(min_value=2, max_value=10),
        num_failed=st.integers(min_value=1, max_value=5)
    )
    @patch("shared.launch_config_service.boto3")
    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_property_5_partial_failure_error_visibility(
        self,
        mock_table,
        mock_boto3,
        group_id,
        region,
        num_servers,
        num_failed
    ):
        """
        Feature: launch-config-preapplication, Property 5:
        For any configuration application with partial failures, only
        failed servers should have error messages, and successful servers
        should have empty errors arrays.
    
        Validates: Requirements 2.4, 3.4
        """
        # Ensure num_failed doesn't exceed num_servers
        num_failed = min(num_failed, num_servers)
    
        # Generate server IDs
        server_ids = [f"s-{'0' * 16}{i}" for i in range(num_servers)]
    
        # Create launch configs for all servers
        launch_configs = {
            server_id: {
                "instanceType": "t3.medium",
                "copyPrivateIp": True
            }
            for server_id in server_ids
        }
    
        # Mock DRS client to fail on first num_failed servers
        mock_drs_client = MagicMock()
    
        def side_effect(**kwargs):
            server_id = kwargs.get("sourceServerID")
            if server_ids.index(server_id) < num_failed:
                # Fail
                from botocore.exceptions import ClientError
                raise ClientError(
                    {
                        "Error": {
                            "Code": "ValidationException",
                            "Message": "Invalid configuration"
                        }
                    },
                    "update_launch_configuration"
                )
            else:
                # Success
                return {}
    
        mock_drs_client.update_launch_configuration.side_effect = side_effect
        mock_boto3.client.return_value = mock_drs_client
    
        # Apply configurations
        result = apply_launch_configs_to_group(
            group_id=group_id,
            region=region,
            server_ids=server_ids,
            launch_configs=launch_configs
        )
    
        # Property: Failed servers must have errors
        failed_servers = server_ids[:num_failed]
        for server_id in failed_servers:
            server_config = result["serverConfigs"][server_id]
            assert server_config["status"] == "failed", (
                f"Server {server_id} should have failed"
            )
            assert len(server_config["errors"]) > 0, (
                f"Failed server {server_id} must have error messages"
            )
    
        # Property: Successful servers must have empty errors
        successful_servers = server_ids[num_failed:]
        for server_id in successful_servers:
            server_config = result["serverConfigs"][server_id]
>           assert server_config["status"] == "ready", (
                f"Server {server_id} should have succeeded"
            )
E           AssertionError: Server s-00000000000000001 should have succeeded
E           assert 'failed' == 'ready'
E             
E             - ready
E             + failed
E           Falsifying example: test_property_5_partial_failure_error_visibility(
E               <tests.unit.test_launch_config_service_property.TestProperty5ErrorVisibility object at 0x10d8f1130>,
E               group_id='0',
E               region='us-east-1',
E               num_servers=2,
E               num_failed=1,
E           )

tests/unit/test_launch_config_service_property.py:2793: AssertionError
------------------------------ Captured log call -------------------------------
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 2 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000001: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=2
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 2 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000001: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=2
_ TestProperty3WaveExecutionFastPath.test_property_3_ready_status_skips_config_application _

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-000'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f1550>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:2879: in test_property_3_ready_status_skips_config_application
    config_status = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_3_ready_status_skips_config_application(
E               <tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f1550>,
E               group_id='pg-000',
E               server_ids=['s-00000000000000000'],
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty3WaveExecutionFastPath.test_property_3_ready_status_has_valid_config_hashes _

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-000'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f17f0>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:2966: in test_property_3_ready_status_has_valid_config_hashes
    config_status = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_3_ready_status_has_valid_config_hashes(
E               <tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f17f0>,
E               group_id='pg-000',
E               server_ids=['s-00000000000000000'],
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty3WaveExecutionFastPath.test_property_3_non_ready_status_requires_config_application _

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-000'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f1a90>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:3064: in test_property_3_non_ready_status_requires_config_application
    config_status = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_3_non_ready_status_requires_config_application(
E               <tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f1a90>,
E               group_id='pg-000',
E               non_ready_status='pending',
E               server_ids=['s-00000000000000000'],
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty3WaveExecutionFastPath.test_property_3_missing_status_requires_config_application _

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-000'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f1d30>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:3122: in test_property_3_missing_status_requires_config_application
    config_status = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_3_missing_status_requires_config_application(
E               <tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f1d30>,
E               group_id='pg-000',
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty3WaveExecutionFastPath.test_property_3_fast_path_decision_is_deterministic _

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-000'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

args = (<tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f1fd0>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
tests/unit/test_launch_config_service_property.py:3203: in test_property_3_fast_path_decision_is_deterministic
    status1 = get_config_status(group_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-000'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException
E           Falsifying example: test_property_3_fast_path_decision_is_deterministic(
E               <tests.unit.test_launch_config_service_property.TestProperty3WaveExecutionFastPath object at 0x10d8f1fd0>,
E               group_id='pg-000',
E               server_ids=['s-00000000000000000'],
E           )

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-000: UnrecognizedClientException - The security token included in the request is invalid.
_ TestProperty11StatusTransitionValidity.test_property_11_success_transitions_to_ready _

args = (<tests.unit.test_launch_config_service_property.TestProperty11StatusTransitionValidity object at 0x10d8f2690>,)
keywargs = {}

    @wraps(func)
>   def patched(*args, **keywargs):

/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.12_2/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1396: in patched
    return func(*newargs, **newkeywargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.unit.test_launch_config_service_property.TestProperty11StatusTransitionValidity object at 0x10d8f2690>
mock_table = <MagicMock name='_get_protection_groups_table' id='4983430304'>
mock_boto3 = <MagicMock name='boto3' id='4983434144'>, group_id = '0'
server_ids = ['s-00000000000000000']

    @given(
        group_id=st.text(min_size=1, max_size=50),
        server_ids=st.lists(
            server_id_strategy(),
            min_size=1,
            max_size=5,
            unique=True
        ),
    )
    @settings(max_examples=50)
    @patch("shared.launch_config_service.boto3")
    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_property_11_success_transitions_to_ready(
        self,
        mock_table,
        mock_boto3,
        group_id,
        server_ids
    ):
        """
        Feature: launch-config-preapplication, Property 11:
        For any apply operation where all servers succeed, the final
        status must be "ready".
    
        **Validates: Requirements 1.4, 3.3, 4.5**
        """
        # Create launch configs for all servers
        launch_configs = {
            server_id: {
                "instanceType": "t3.medium",
                "copyPrivateIp": True
            }
            for server_id in server_ids
        }
    
        # Mock DRS client to succeed for all servers
        mock_drs_client = MagicMock()
        mock_drs_client.update_launch_configuration.return_value = {}
        mock_boto3.client.return_value = mock_drs_client
    
        # Apply configurations
        result = apply_launch_configs_to_group(
            group_id=group_id,
            region="us-east-2",
            server_ids=server_ids,
            launch_configs=launch_configs
        )
    
        # Property: All success must result in "ready" status
>       assert result["status"] == "ready", (
            f"All servers succeeded, status should be 'ready', "
            f"got '{result['status']}'"
        )
E       AssertionError: All servers succeeded, status should be 'ready', got 'failed'
E       assert 'failed' == 'ready'
E         
E         - ready
E         + failed
E       Falsifying example: test_property_11_success_transitions_to_ready(
E           <tests.unit.test_launch_config_service_property.TestProperty11StatusTransitionValidity object at 0x10d8f2690>,
E           group_id='0',
E           server_ids=['s-00000000000000000'],
E       )

tests/unit/test_launch_config_service_property.py:3365: AssertionError
------------------------------ Captured log call -------------------------------
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 1 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=1
INFO     shared.launch_config_service:launch_config_service.py:138 Applying launch configs to group 0 with 1 servers (timeout: 300s)
ERROR    shared.launch_config_service:launch_config_service.py:231 Failed to apply config to server s-00000000000000000: DRS API error (UnrecognizedClientException): The security token included in the request is invalid.
INFO     shared.launch_config_service:launch_config_service.py:249 Config application complete for 0: status=failed, applied=0, failed=1
__________ TestPersistConfigStatus.test_persist_valid_status_succeeds __________

group_id = 'pg-123'
config_status = {'appliedBy': 'user@example.com', 'errors': [], 'lastApplied': '2025-02-16T10:30:00Z', 'serverConfigs': {}, ...}

    def persist_config_status(group_id: str, config_status: Dict) -> None:
        """
        Persist configuration status to DynamoDB.
    
        Updates the launchConfigStatus field in the protection group item.
        Uses atomic update to ensure consistency.
    
        Args:
            group_id: Protection group ID
            config_status: Status dictionary to persist with keys:
                - status: Overall status (ready | pending | failed)
                - lastApplied: ISO timestamp
                - appliedBy: User identifier
                - serverConfigs: Per-server configuration status
                - errors: List of error messages
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB update fails
    
        Example:
            >>> status = {
            ...     "status": "ready",
            ...     "lastApplied": "2025-02-16T10:30:00Z",
            ...     "appliedBy": "user@example.com",
            ...     "serverConfigs": {},
            ...     "errors": []
            ... }
            >>> persist_config_status("pg-123", status)
    
        Validates: Requirements 1.4 (status persistence)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        if not config_status:
            raise LaunchConfigValidationError("config_status is required")
    
        # Validate required fields
        required_fields = ["status", "serverConfigs", "errors"]
        for field in required_fields:
            if field not in config_status:
                raise LaunchConfigValidationError(f"config_status missing required field: {field}")
    
        try:
            table = _get_protection_groups_table()
    
            # Update protection group with configuration status
>           table.update_item(
                Key={"groupId": group_id},
                UpdateExpression="SET launchConfigStatus = :status",
                ExpressionAttributeValues={":status": config_status},
            )

lambda/shared/launch_config_service.py:620: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'UpdateItem'
api_params = {'ExpressionAttributeValues': {':status': {'M': {'appliedBy': {'S': 'user@example.com'}, 'errors': {'L': []}, 'lastApp... {'S': 'pg-123'}}, 'TableName': 'test-protection-groups-table', 'UpdateExpression': 'SET launchConfigStatus = :status'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the UpdateItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestPersistConfigStatus object at 0x10d935640>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='5128053408'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_persist_valid_status_succeeds(self, mock_get_table):
        """Test persisting valid configuration status succeeds."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        config_status = {
            "status": "ready",
            "lastApplied": "2025-02-16T10:30:00Z",
            "appliedBy": "user@example.com",
            "serverConfigs": {},
            "errors": [],
        }
    
>       persist_config_status("pg-123", config_status)

tests/unit/test_launch_config_service_unit.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-123'
config_status = {'appliedBy': 'user@example.com', 'errors': [], 'lastApplied': '2025-02-16T10:30:00Z', 'serverConfigs': {}, ...}

    def persist_config_status(group_id: str, config_status: Dict) -> None:
        """
        Persist configuration status to DynamoDB.
    
        Updates the launchConfigStatus field in the protection group item.
        Uses atomic update to ensure consistency.
    
        Args:
            group_id: Protection group ID
            config_status: Status dictionary to persist with keys:
                - status: Overall status (ready | pending | failed)
                - lastApplied: ISO timestamp
                - appliedBy: User identifier
                - serverConfigs: Per-server configuration status
                - errors: List of error messages
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB update fails
    
        Example:
            >>> status = {
            ...     "status": "ready",
            ...     "lastApplied": "2025-02-16T10:30:00Z",
            ...     "appliedBy": "user@example.com",
            ...     "serverConfigs": {},
            ...     "errors": []
            ... }
            >>> persist_config_status("pg-123", status)
    
        Validates: Requirements 1.4 (status persistence)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        if not config_status:
            raise LaunchConfigValidationError("config_status is required")
    
        # Validate required fields
        required_fields = ["status", "serverConfigs", "errors"]
        for field in required_fields:
            if field not in config_status:
                raise LaunchConfigValidationError(f"config_status missing required field: {field}")
    
        try:
            table = _get_protection_groups_table()
    
            # Update protection group with configuration status
            table.update_item(
                Key={"groupId": group_id},
                UpdateExpression="SET launchConfigStatus = :status",
                ExpressionAttributeValues={":status": config_status},
            )
    
            logger.info(f"Persisted config status for group {group_id}: " f"status={config_status['status']}")
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to persist config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB update failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB update failed: UnrecognizedClientException

lambda/shared/launch_config_service.py:632: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:631 Failed to persist config status for pg-123: UnrecognizedClientException - The security token included in the request is invalid.
___________ TestPersistConfigStatus.test_persist_with_server_configs ___________

group_id = 'pg-123'
config_status = {'appliedBy': 'user@example.com', 'errors': [], 'lastApplied': '2025-02-16T10:30:00Z', 'serverConfigs': {'s-1234567890abcdef0': {'configHash': 'sha256:abc123', 'errors': [], 'lastApplied': '2025-02-16T10:30:00Z', 'status': 'ready'}}, ...}

    def persist_config_status(group_id: str, config_status: Dict) -> None:
        """
        Persist configuration status to DynamoDB.
    
        Updates the launchConfigStatus field in the protection group item.
        Uses atomic update to ensure consistency.
    
        Args:
            group_id: Protection group ID
            config_status: Status dictionary to persist with keys:
                - status: Overall status (ready | pending | failed)
                - lastApplied: ISO timestamp
                - appliedBy: User identifier
                - serverConfigs: Per-server configuration status
                - errors: List of error messages
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB update fails
    
        Example:
            >>> status = {
            ...     "status": "ready",
            ...     "lastApplied": "2025-02-16T10:30:00Z",
            ...     "appliedBy": "user@example.com",
            ...     "serverConfigs": {},
            ...     "errors": []
            ... }
            >>> persist_config_status("pg-123", status)
    
        Validates: Requirements 1.4 (status persistence)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        if not config_status:
            raise LaunchConfigValidationError("config_status is required")
    
        # Validate required fields
        required_fields = ["status", "serverConfigs", "errors"]
        for field in required_fields:
            if field not in config_status:
                raise LaunchConfigValidationError(f"config_status missing required field: {field}")
    
        try:
            table = _get_protection_groups_table()
    
            # Update protection group with configuration status
>           table.update_item(
                Key={"groupId": group_id},
                UpdateExpression="SET launchConfigStatus = :status",
                ExpressionAttributeValues={":status": config_status},
            )

lambda/shared/launch_config_service.py:620: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'UpdateItem'
api_params = {'ExpressionAttributeValues': {':status': {'M': {'appliedBy': {'S': 'user@example.com'}, 'errors': {'L': []}, 'lastApp... {'S': 'pg-123'}}, 'TableName': 'test-protection-groups-table', 'UpdateExpression': 'SET launchConfigStatus = :status'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the UpdateItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestPersistConfigStatus object at 0x10d9358e0>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='5044007328'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_persist_with_server_configs(self, mock_get_table):
        """Test persisting status with per-server configurations."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        config_status = {
            "status": "ready",
            "lastApplied": "2025-02-16T10:30:00Z",
            "appliedBy": "user@example.com",
            "serverConfigs": {
                "s-1234567890abcdef0": {
                    "status": "ready",
                    "lastApplied": "2025-02-16T10:30:00Z",
                    "configHash": "sha256:abc123",
                    "errors": [],
                }
            },
            "errors": [],
        }
    
>       persist_config_status("pg-123", config_status)

tests/unit/test_launch_config_service_unit.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-123'
config_status = {'appliedBy': 'user@example.com', 'errors': [], 'lastApplied': '2025-02-16T10:30:00Z', 'serverConfigs': {'s-1234567890abcdef0': {'configHash': 'sha256:abc123', 'errors': [], 'lastApplied': '2025-02-16T10:30:00Z', 'status': 'ready'}}, ...}

    def persist_config_status(group_id: str, config_status: Dict) -> None:
        """
        Persist configuration status to DynamoDB.
    
        Updates the launchConfigStatus field in the protection group item.
        Uses atomic update to ensure consistency.
    
        Args:
            group_id: Protection group ID
            config_status: Status dictionary to persist with keys:
                - status: Overall status (ready | pending | failed)
                - lastApplied: ISO timestamp
                - appliedBy: User identifier
                - serverConfigs: Per-server configuration status
                - errors: List of error messages
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB update fails
    
        Example:
            >>> status = {
            ...     "status": "ready",
            ...     "lastApplied": "2025-02-16T10:30:00Z",
            ...     "appliedBy": "user@example.com",
            ...     "serverConfigs": {},
            ...     "errors": []
            ... }
            >>> persist_config_status("pg-123", status)
    
        Validates: Requirements 1.4 (status persistence)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        if not config_status:
            raise LaunchConfigValidationError("config_status is required")
    
        # Validate required fields
        required_fields = ["status", "serverConfigs", "errors"]
        for field in required_fields:
            if field not in config_status:
                raise LaunchConfigValidationError(f"config_status missing required field: {field}")
    
        try:
            table = _get_protection_groups_table()
    
            # Update protection group with configuration status
            table.update_item(
                Key={"groupId": group_id},
                UpdateExpression="SET launchConfigStatus = :status",
                ExpressionAttributeValues={":status": config_status},
            )
    
            logger.info(f"Persisted config status for group {group_id}: " f"status={config_status['status']}")
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to persist config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB update failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB update failed: UnrecognizedClientException

lambda/shared/launch_config_service.py:632: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:631 Failed to persist config status for pg-123: UnrecognizedClientException - The security token included in the request is invalid.
_______________ TestPersistConfigStatus.test_persist_with_errors _______________

group_id = 'pg-123'
config_status = {'appliedBy': 'user@example.com', 'errors': ['DRS API timeout', 'Invalid configuration'], 'lastApplied': '2025-02-16T10:30:00Z', 'serverConfigs': {}, ...}

    def persist_config_status(group_id: str, config_status: Dict) -> None:
        """
        Persist configuration status to DynamoDB.
    
        Updates the launchConfigStatus field in the protection group item.
        Uses atomic update to ensure consistency.
    
        Args:
            group_id: Protection group ID
            config_status: Status dictionary to persist with keys:
                - status: Overall status (ready | pending | failed)
                - lastApplied: ISO timestamp
                - appliedBy: User identifier
                - serverConfigs: Per-server configuration status
                - errors: List of error messages
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB update fails
    
        Example:
            >>> status = {
            ...     "status": "ready",
            ...     "lastApplied": "2025-02-16T10:30:00Z",
            ...     "appliedBy": "user@example.com",
            ...     "serverConfigs": {},
            ...     "errors": []
            ... }
            >>> persist_config_status("pg-123", status)
    
        Validates: Requirements 1.4 (status persistence)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        if not config_status:
            raise LaunchConfigValidationError("config_status is required")
    
        # Validate required fields
        required_fields = ["status", "serverConfigs", "errors"]
        for field in required_fields:
            if field not in config_status:
                raise LaunchConfigValidationError(f"config_status missing required field: {field}")
    
        try:
            table = _get_protection_groups_table()
    
            # Update protection group with configuration status
>           table.update_item(
                Key={"groupId": group_id},
                UpdateExpression="SET launchConfigStatus = :status",
                ExpressionAttributeValues={":status": config_status},
            )

lambda/shared/launch_config_service.py:620: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'UpdateItem'
api_params = {'ExpressionAttributeValues': {':status': {'M': {'appliedBy': {'S': 'user@example.com'}, 'errors': {'L': [{...}, {...}... {'S': 'pg-123'}}, 'TableName': 'test-protection-groups-table', 'UpdateExpression': 'SET launchConfigStatus = :status'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the UpdateItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestPersistConfigStatus object at 0x10d935b80>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='4523908064'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_persist_with_errors(self, mock_get_table):
        """Test persisting status with error messages."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        config_status = {
            "status": "failed",
            "lastApplied": "2025-02-16T10:30:00Z",
            "appliedBy": "user@example.com",
            "serverConfigs": {},
            "errors": ["DRS API timeout", "Invalid configuration"],
        }
    
>       persist_config_status("pg-123", config_status)

tests/unit/test_launch_config_service_unit.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-123'
config_status = {'appliedBy': 'user@example.com', 'errors': ['DRS API timeout', 'Invalid configuration'], 'lastApplied': '2025-02-16T10:30:00Z', 'serverConfigs': {}, ...}

    def persist_config_status(group_id: str, config_status: Dict) -> None:
        """
        Persist configuration status to DynamoDB.
    
        Updates the launchConfigStatus field in the protection group item.
        Uses atomic update to ensure consistency.
    
        Args:
            group_id: Protection group ID
            config_status: Status dictionary to persist with keys:
                - status: Overall status (ready | pending | failed)
                - lastApplied: ISO timestamp
                - appliedBy: User identifier
                - serverConfigs: Per-server configuration status
                - errors: List of error messages
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB update fails
    
        Example:
            >>> status = {
            ...     "status": "ready",
            ...     "lastApplied": "2025-02-16T10:30:00Z",
            ...     "appliedBy": "user@example.com",
            ...     "serverConfigs": {},
            ...     "errors": []
            ... }
            >>> persist_config_status("pg-123", status)
    
        Validates: Requirements 1.4 (status persistence)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        if not config_status:
            raise LaunchConfigValidationError("config_status is required")
    
        # Validate required fields
        required_fields = ["status", "serverConfigs", "errors"]
        for field in required_fields:
            if field not in config_status:
                raise LaunchConfigValidationError(f"config_status missing required field: {field}")
    
        try:
            table = _get_protection_groups_table()
    
            # Update protection group with configuration status
            table.update_item(
                Key={"groupId": group_id},
                UpdateExpression="SET launchConfigStatus = :status",
                ExpressionAttributeValues={":status": config_status},
            )
    
            logger.info(f"Persisted config status for group {group_id}: " f"status={config_status['status']}")
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to persist config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB update failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB update failed: UnrecognizedClientException

lambda/shared/launch_config_service.py:632: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:631 Failed to persist config status for pg-123: UnrecognizedClientException - The security token included in the request is invalid.
___________ TestPersistConfigStatus.test_persist_uses_atomic_update ____________

group_id = 'pg-123'
config_status = {'errors': [], 'serverConfigs': {}, 'status': 'ready'}

    def persist_config_status(group_id: str, config_status: Dict) -> None:
        """
        Persist configuration status to DynamoDB.
    
        Updates the launchConfigStatus field in the protection group item.
        Uses atomic update to ensure consistency.
    
        Args:
            group_id: Protection group ID
            config_status: Status dictionary to persist with keys:
                - status: Overall status (ready | pending | failed)
                - lastApplied: ISO timestamp
                - appliedBy: User identifier
                - serverConfigs: Per-server configuration status
                - errors: List of error messages
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB update fails
    
        Example:
            >>> status = {
            ...     "status": "ready",
            ...     "lastApplied": "2025-02-16T10:30:00Z",
            ...     "appliedBy": "user@example.com",
            ...     "serverConfigs": {},
            ...     "errors": []
            ... }
            >>> persist_config_status("pg-123", status)
    
        Validates: Requirements 1.4 (status persistence)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        if not config_status:
            raise LaunchConfigValidationError("config_status is required")
    
        # Validate required fields
        required_fields = ["status", "serverConfigs", "errors"]
        for field in required_fields:
            if field not in config_status:
                raise LaunchConfigValidationError(f"config_status missing required field: {field}")
    
        try:
            table = _get_protection_groups_table()
    
            # Update protection group with configuration status
>           table.update_item(
                Key={"groupId": group_id},
                UpdateExpression="SET launchConfigStatus = :status",
                ExpressionAttributeValues={":status": config_status},
            )

lambda/shared/launch_config_service.py:620: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'UpdateItem'
api_params = {'ExpressionAttributeValues': {':status': {'M': {'errors': {'L': []}, 'serverConfigs': {'M': {}}, 'status': {'S': 'rea... {'S': 'pg-123'}}, 'TableName': 'test-protection-groups-table', 'UpdateExpression': 'SET launchConfigStatus = :status'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the UpdateItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestPersistConfigStatus object at 0x10d937470>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='5066400656'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_persist_uses_atomic_update(self, mock_get_table):
        """Test persist uses atomic DynamoDB update operation."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        config_status = {
            "status": "ready",
            "serverConfigs": {},
            "errors": [],
        }
    
>       persist_config_status("pg-123", config_status)

tests/unit/test_launch_config_service_unit.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-123'
config_status = {'errors': [], 'serverConfigs': {}, 'status': 'ready'}

    def persist_config_status(group_id: str, config_status: Dict) -> None:
        """
        Persist configuration status to DynamoDB.
    
        Updates the launchConfigStatus field in the protection group item.
        Uses atomic update to ensure consistency.
    
        Args:
            group_id: Protection group ID
            config_status: Status dictionary to persist with keys:
                - status: Overall status (ready | pending | failed)
                - lastApplied: ISO timestamp
                - appliedBy: User identifier
                - serverConfigs: Per-server configuration status
                - errors: List of error messages
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB update fails
    
        Example:
            >>> status = {
            ...     "status": "ready",
            ...     "lastApplied": "2025-02-16T10:30:00Z",
            ...     "appliedBy": "user@example.com",
            ...     "serverConfigs": {},
            ...     "errors": []
            ... }
            >>> persist_config_status("pg-123", status)
    
        Validates: Requirements 1.4 (status persistence)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        if not config_status:
            raise LaunchConfigValidationError("config_status is required")
    
        # Validate required fields
        required_fields = ["status", "serverConfigs", "errors"]
        for field in required_fields:
            if field not in config_status:
                raise LaunchConfigValidationError(f"config_status missing required field: {field}")
    
        try:
            table = _get_protection_groups_table()
    
            # Update protection group with configuration status
            table.update_item(
                Key={"groupId": group_id},
                UpdateExpression="SET launchConfigStatus = :status",
                ExpressionAttributeValues={":status": config_status},
            )
    
            logger.info(f"Persisted config status for group {group_id}: " f"status={config_status['status']}")
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to persist config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB update failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB update failed: UnrecognizedClientException

lambda/shared/launch_config_service.py:632: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:631 Failed to persist config status for pg-123: UnrecognizedClientException - The security token included in the request is invalid.
_________ TestGetConfigStatus.test_get_existing_status_returns_status __________

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-123'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestGetConfigStatus object at 0x10d936570>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='4826699616'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_get_existing_status_returns_status(self, mock_get_table):
        """Test retrieving existing configuration status."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        expected_status = {
            "status": "ready",
            "lastApplied": "2025-02-16T10:30:00Z",
            "appliedBy": "user@example.com",
            "serverConfigs": {},
            "errors": [],
        }
    
        mock_table.get_item.return_value = {
            "Item": {"groupId": "pg-123", "launchConfigStatus": expected_status}
        }
    
>       result = get_config_status("pg-123")

tests/unit/test_launch_config_service_unit.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-123: UnrecognizedClientException - The security token included in the request is invalid.
__ TestGetConfigStatus.test_get_status_without_launch_config_returns_default ___

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-123'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestGetConfigStatus object at 0x10d935790>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='4523433408'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_get_status_without_launch_config_returns_default(
        self, mock_get_table
    ):
        """Test retrieving status for group without config returns default."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        mock_table.get_item.return_value = {
            "Item": {"groupId": "pg-123", "groupName": "Test Group"}
        }
    
>       result = get_config_status("pg-123")

tests/unit/test_launch_config_service_unit.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-123: UnrecognizedClientException - The security token included in the request is invalid.
_______ TestGetConfigStatus.test_get_status_group_not_found_raises_error _______

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-123'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestGetConfigStatus object at 0x10d934ad0>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='5036806064'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_get_status_group_not_found_raises_error(self, mock_get_table):
        """Test retrieving status for non-existent group raises error."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        mock_table.get_item.return_value = {}
    
        with pytest.raises(
            LaunchConfigApplicationError,
            match="Protection group pg-123 not found",
        ):
>           get_config_status("pg-123")

tests/unit/test_launch_config_service_unit.py:379: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestGetConfigStatus object at 0x10d934ad0>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='5036806064'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_get_status_group_not_found_raises_error(self, mock_get_table):
        """Test retrieving status for non-existent group raises error."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        mock_table.get_item.return_value = {}
    
>       with pytest.raises(
            LaunchConfigApplicationError,
            match="Protection group pg-123 not found",
        ):
E       AssertionError: Regex pattern did not match.
E        Regex: 'Protection group pg-123 not found'
E        Input: 'DynamoDB query failed: UnrecognizedClientException'

tests/unit/test_launch_config_service_unit.py:375: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-123: UnrecognizedClientException - The security token included in the request is invalid.
___________ TestGetConfigStatus.test_get_status_with_server_configs ____________

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-123'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestGetConfigStatus object at 0x10d937f50>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='4552825008'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_get_status_with_server_configs(self, mock_get_table):
        """Test retrieving status with per-server configurations."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        expected_status = {
            "status": "ready",
            "lastApplied": "2025-02-16T10:30:00Z",
            "appliedBy": "user@example.com",
            "serverConfigs": {
                "s-1234567890abcdef0": {
                    "status": "ready",
                    "lastApplied": "2025-02-16T10:30:00Z",
                    "configHash": "sha256:abc123",
                    "errors": [],
                }
            },
            "errors": [],
        }
    
        mock_table.get_item.return_value = {
            "Item": {"groupId": "pg-123", "launchConfigStatus": expected_status}
        }
    
>       result = get_config_status("pg-123")

tests/unit/test_launch_config_service_unit.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-123: UnrecognizedClientException - The security token included in the request is invalid.
_______________ TestGetConfigStatus.test_get_status_with_errors ________________

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
>           response = table.get_item(Key={"groupId": group_id})

lambda/shared/launch_config_service.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/boto3/resources/factory.py:581: in do_action
    response = action(self, *args, **kwargs)
.venv/lib/python3.12/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
.venv/lib/python3.12/site-packages/botocore/client.py:569: in _api_call
    return self._make_api_call(operation_name, kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.client.DynamoDB object at 0x12df25d90>
operation_name = 'GetItem'
api_params = {'Key': {'groupId': {'S': 'pg-123'}}, 'TableName': 'test-protection-groups-table'}

    def _make_api_call(self, operation_name, api_params):
        operation_model = self._service_model.operation_model(operation_name)
        service_name = self._service_model.service_name
        history_recorder.record(
            'API_CALL',
            {
                'service': service_name,
                'operation': operation_name,
                'params': api_params,
            },
        )
        if operation_model.deprecated:
            logger.debug(
                'Warning: %s.%s() is deprecated', service_name, operation_name
            )
        request_context = {
            'client_region': self.meta.region_name,
            'client_config': self.meta.config,
            'has_streaming_input': operation_model.has_streaming_input,
            'auth_type': operation_model.resolved_auth_type,
            'unsigned_payload': operation_model.unsigned_payload,
        }
    
        api_params = self._emit_api_params(
            api_params=api_params,
            operation_model=operation_model,
            context=request_context,
        )
        (
            endpoint_url,
            additional_headers,
            properties,
        ) = self._resolve_endpoint_ruleset(
            operation_model, api_params, request_context
        )
        if properties:
            # Pass arbitrary endpoint info with the Request
            # for use during construction.
            request_context['endpoint_properties'] = properties
        request_dict = self._convert_to_request_dict(
            api_params=api_params,
            operation_model=operation_model,
            endpoint_url=endpoint_url,
            context=request_context,
            headers=additional_headers,
        )
        resolve_checksum_context(request_dict, operation_model, api_params)
    
        service_id = self._service_model.service_id.hyphenize()
        handler, event_response = self.meta.events.emit_until_response(
            f'before-call.{service_id}.{operation_name}',
            model=operation_model,
            params=request_dict,
            request_signer=self._request_signer,
            context=request_context,
        )
    
        if event_response is not None:
            http, parsed_response = event_response
        else:
            maybe_compress_request(
                self.meta.config, request_dict, operation_model
            )
            apply_request_checksum(request_dict)
            http, parsed_response = self._make_request(
                operation_model, request_dict, request_context
            )
    
        self.meta.events.emit(
            f'after-call.{service_id}.{operation_name}',
            http_response=http,
            parsed=parsed_response,
            model=operation_model,
            context=request_context,
        )
    
        if http.status_code >= 300:
            error_info = parsed_response.get("Error", {})
            error_code = error_info.get("QueryErrorCode") or error_info.get(
                "Code"
            )
            error_class = self.exceptions.from_code(error_code)
>           raise error_class(parsed_response, operation_name)
E           botocore.exceptions.ClientError: An error occurred (UnrecognizedClientException) when calling the GetItem operation: The security token included in the request is invalid.

.venv/lib/python3.12/site-packages/botocore/client.py:1023: ClientError

During handling of the above exception, another exception occurred:

self = <tests.unit.test_launch_config_service_unit.TestGetConfigStatus object at 0x10d948230>
mock_get_table = <MagicMock name='_get_protection_groups_table' id='5066143024'>

    @patch("shared.launch_config_service._get_protection_groups_table")
    def test_get_status_with_errors(self, mock_get_table):
        """Test retrieving status with error messages."""
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
    
        expected_status = {
            "status": "failed",
            "lastApplied": "2025-02-16T10:30:00Z",
            "appliedBy": "user@example.com",
            "serverConfigs": {},
            "errors": ["DRS API timeout", "Invalid configuration"],
        }
    
        mock_table.get_item.return_value = {
            "Item": {"groupId": "pg-123", "launchConfigStatus": expected_status}
        }
    
>       result = get_config_status("pg-123")

tests/unit/test_launch_config_service_unit.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

group_id = 'pg-123'

    def get_config_status(group_id: str) -> Dict:
        """
        Retrieve configuration status from DynamoDB.
    
        Args:
            group_id: Protection group ID
    
        Returns:
            Configuration status dictionary with keys:
            - status: Overall status (ready | pending | failed | not_configured)
            - lastApplied: ISO timestamp (optional)
            - appliedBy: User identifier (optional)
            - serverConfigs: Per-server configuration status
            - errors: List of error messages
    
            If no status exists, returns default not_configured status.
    
        Raises:
            LaunchConfigApplicationError: If DynamoDB query fails
    
        Example:
            >>> status = get_config_status("pg-123")
            >>> status["status"]
            'ready'
    
        Validates: Requirements 2.1, 2.2 (status retrieval)
        """
        if not group_id:
            raise LaunchConfigValidationError("group_id is required")
    
        try:
            table = _get_protection_groups_table()
    
            response = table.get_item(Key={"groupId": group_id})
    
            if "Item" not in response:
                logger.warning(f"Protection group {group_id} not found")
                raise LaunchConfigApplicationError(f"Protection group {group_id} not found")
    
            item = response["Item"]
    
            # Return launchConfigStatus if it exists, otherwise default status
            if "launchConfigStatus" in item:
                return item["launchConfigStatus"]
            else:
                # Default status for groups without configuration status
                return {
                    "status": "not_configured",
                    "lastApplied": None,
                    "appliedBy": None,
                    "serverConfigs": {},
                    "errors": [],
                }
    
        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]
            logger.error(f"Failed to get config status for {group_id}: " f"{error_code} - {error_message}")
>           raise LaunchConfigApplicationError(f"DynamoDB query failed: {error_code}")
E           shared.launch_config_service.LaunchConfigApplicationError: DynamoDB query failed: UnrecognizedClientException

lambda/shared/launch_config_service.py:693: LaunchConfigApplicationError
------------------------------ Captured log call -------------------------------
ERROR    shared.launch_config_service:launch_config_service.py:692 Failed to get config status for pg-123: UnrecognizedClientException - The security token included in the request is invalid.
_ TestEnvironmentVariableHandling.test_missing_table_name_env_var_raises_error _

self = <tests.unit.test_launch_config_service_unit.TestEnvironmentVariableHandling object at 0x10d949850>
mock_get_resource = <MagicMock name='_get_dynamodb_resource' id='5144408144'>

    @patch.dict(os.environ, {}, clear=True)
    @patch("shared.launch_config_service._get_dynamodb_resource")
    def test_missing_table_name_env_var_raises_error(self, mock_get_resource):
        """Test missing PROTECTION_GROUPS_TABLE env var raises error."""
        # Reset global variables
        import shared.launch_config_service as service
    
        service._protection_groups_table = None
    
        mock_dynamodb = MagicMock()
        mock_get_resource.return_value = mock_dynamodb
    
        with pytest.raises(
            LaunchConfigApplicationError,
            match="PROTECTION_GROUPS_TABLE environment variable not set",
        ):
>           service._get_protection_groups_table()

tests/unit/test_launch_config_service_unit.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_protection_groups_table():
        """Get or create protection groups table reference."""
        global _protection_groups_table
        if _protection_groups_table is None:
            table_name = os.environ.get("PROTECTION_GROUPS_TABLE")
            if not table_name:
>               raise LaunchConfigApplicationError("PROTECTION_GROUPS_TABLE environment variable not set")
E               shared.launch_config_service.LaunchConfigApplicationError: PROTECTION_GROUPS_TABLE environment variable not set

lambda/shared/launch_config_service.py:57: LaunchConfigApplicationError
________________ test_property_multi_account_query_parallelism _________________

    def wrapper(*args: Any, **kwargs: Any) -> T:
>       self.start(reset=reset)

.venv/lib/python3.12/site-packages/moto/core/models.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/moto/core/models.py:122: in wrapper
    result = func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = ({'accountId': '000000000000', 'accountName': '0', 'externalId': '0', 'roleArn': 'arn:aws:iam::000000000000:role/0'}, [])

    @settings(max_examples=50, deadline=2000)
    @given(config=multi_account_config_strategy())
    @mock_aws
    @pytest.mark.property
    def test_property_multi_account_query_parallelism(config):
        """
        Property 8: Multi-Account Query Parallelism
    
        For any target account with N staging accounts:
        1. Should initiate N+1 concurrent account queries (target + staging)
        2. Each account query should query all DRS regions
        3. All queries should execute in parallel (not sequentially)
        """
        # Import boto3 and reload index INSIDE the test after @mock_aws is active
        import boto3
    
        # Clear and reload index module to use mocked AWS
        if "index" in sys.modules:
            del sys.modules["index"]
        import index
>       from index import query_all_accounts_parallel  # noqa: F401
E       ImportError: cannot import name 'query_all_accounts_parallel' from 'index' (/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/../../lambda/data-management-handler/index.py)
E       Falsifying example: test_property_multi_account_query_parallelism(
E           config=({'accountId': '000000000000',
E             'accountName': '0',
E             'roleArn': 'arn:aws:iam::000000000000:role/0',
E             'externalId': '0'},
E            []),
E       )

tests/unit/test_multi_account_query_parallelism_property.py:123: ImportError
_____________ test_property_concurrent_region_queries_per_account ______________

    def wrapper(*args: Any, **kwargs: Any) -> T:
>       self.start(reset=reset)

.venv/lib/python3.12/site-packages/moto/core/models.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/moto/core/models.py:122: in wrapper
    result = func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

num_staging = 0, num_regions = 1

    @settings(max_examples=30, deadline=2000)
    @given(num_staging=st.integers(min_value=0, max_value=15), num_regions=st.integers(min_value=1, max_value=20))
    @mock_aws
    @pytest.mark.property
    def test_property_concurrent_region_queries_per_account(num_staging, num_regions):
        """
        Property: Each account query should query all regions concurrently
    
        This test verifies that query_account_capacity queries multiple regions
        in parallel for each account.
        """
        # Import boto3 and reload index INSIDE the test after @mock_aws is active
        import boto3
    
        # Clear and reload index module to use mocked AWS
        if "index" in sys.modules:
            del sys.modules["index"]
        import index
>       from index import query_all_accounts_parallel  # noqa: F401
E       ImportError: cannot import name 'query_all_accounts_parallel' from 'index' (/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/../../lambda/data-management-handler/index.py)
E       Falsifying example: test_property_concurrent_region_queries_per_account(
E           num_staging=0,
E           num_regions=1,
E       )

tests/unit/test_multi_account_query_parallelism_property.py:201: ImportError
_______________ test_property_parallel_execution_not_sequential ________________

    def wrapper(*args: Any, **kwargs: Any) -> T:
>       self.start(reset=reset)

.venv/lib/python3.12/site-packages/moto/core/models.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/moto/core/models.py:122: in wrapper
    result = func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = ({'accountId': '000000000000', 'accountName': '0', 'externalId': '0', 'roleArn': 'arn:aws:iam::000000000000:role/0'}, [])

    @settings(max_examples=50, deadline=3000)
    @given(config=multi_account_config_strategy())
    @mock_aws
    @pytest.mark.property
    def test_property_parallel_execution_not_sequential(config):
        """
        Property: Queries should execute in parallel, not sequentially
    
        This test verifies that all account queries are submitted to the
        ThreadPoolExecutor concurrently, not one after another.
    
        Note: This test verifies that all accounts are queried and results
        are returned, which is the functional requirement. The actual
        parallelism is implementation detail handled by ThreadPoolExecutor.
        """
        # Import boto3 and reload index INSIDE the test after @mock_aws is active
        import boto3
    
        # Clear and reload index module to use mocked AWS
        if "index" in sys.modules:
            del sys.modules["index"]
        import index
>       from index import query_all_accounts_parallel  # noqa: F401
E       ImportError: cannot import name 'query_all_accounts_parallel' from 'index' (/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/../../lambda/data-management-handler/index.py)
E       Falsifying example: test_property_parallel_execution_not_sequential(
E           config=({'accountId': '000000000000',
E             'accountName': '0',
E             'roleArn': 'arn:aws:iam::000000000000:role/0',
E             'externalId': '0'},
E            []),
E       )

tests/unit/test_multi_account_query_parallelism_property.py:279: ImportError
______________________ test_edge_case_no_staging_accounts ______________________

    @mock_aws
    @pytest.mark.property
    def test_edge_case_no_staging_accounts():
        """Edge case: Only target account, no staging accounts."""
        # Import boto3 and reload index INSIDE the test after @mock_aws is active
        import boto3
    
        # Clear and reload index module to use mocked AWS
        if "index" in sys.modules:
            del sys.modules["index"]
        import index
>       from index import query_all_accounts_parallel  # noqa: F401
E       ImportError: cannot import name 'query_all_accounts_parallel' from 'index' (/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/../../lambda/data-management-handler/index.py)

tests/unit/test_multi_account_query_parallelism_property.py:335: ImportError
_____________________ test_edge_case_many_staging_accounts _____________________

    @mock_aws
    @pytest.mark.property
    def test_edge_case_many_staging_accounts():
        """Edge case: Target account with many staging accounts (20)."""
        # Import boto3 and reload index INSIDE the test after @mock_aws is active
        import boto3
    
        # Clear and reload index module to use mocked AWS
        if "index" in sys.modules:
            del sys.modules["index"]
        import index
>       from index import query_all_accounts_parallel  # noqa: F401
E       ImportError: cannot import name 'query_all_accounts_parallel' from 'index' (/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/../../lambda/data-management-handler/index.py)

tests/unit/test_multi_account_query_parallelism_property.py:380: ImportError
____________________ test_edge_case_query_failure_continues ____________________

    @mock_aws
    @pytest.mark.property
    def test_edge_case_query_failure_continues():
        """Edge case: One account query fails, others continue."""
        # Import boto3 and reload index INSIDE the test after @mock_aws is active
        import boto3
    
        # Clear and reload index module to use mocked AWS
        if "index" in sys.modules:
            del sys.modules["index"]
        import index
>       from index import query_all_accounts_parallel  # noqa: F401
E       ImportError: cannot import name 'query_all_accounts_parallel' from 'index' (/Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/../../lambda/data-management-handler/index.py)

tests/unit/test_multi_account_query_parallelism_property.py:432: ImportError
____ TestHandleSyncStagingAccounts.test_successful_sync_with_active_regions ____

self = <tests.unit.test_staging_account_sync_comprehensive.TestHandleSyncStagingAccounts object at 0x10de92c90>

    def test_successful_sync_with_active_regions(self):
        """Test successful staging account sync with active region filtering."""
        active_regions = ["us-east-1", "us-west-2"]
        target_accounts = [
            {
                "accountId": "123456789012",
                "accountName": "Target Account",
                "roleArn": "arn:aws:iam::123456789012:role/DRSRole",
                "externalId": "external123",
                "isCurrentAccount": False,
                "stagingAccounts": [
                    {
                        "accountId": "987654321098",
                        "accountName": "Staging Account",
                        "roleArn": "arn:aws:iam::987654321098:role/StagingRole",
                        "externalId": "staging123",
                    }
                ],
            }
        ]
    
        with patch.object(active_region_filter, "get_active_regions") as mock_get_active:
            with patch.object(dm_handler, "get_target_accounts_table") as mock_table:
                with patch.object(dm_handler, "auto_extend_staging_servers") as mock_extend:
                    # Setup mocks
                    mock_get_active.return_value = active_regions
                    mock_table.return_value.scan.return_value = {"Items": target_accounts}
                    mock_extend.return_value = {
                        "totalAccounts": 1,
                        "accountsProcessed": 1,
                        "serversExtended": 2,
                        "serversFailed": 0,
                        "details": [],
                    }
    
                    # Execute
                    result = dm_handler.handle_sync_staging_accounts()
    
                    # Verify
                    assert result["statusCode"] == 200
                    body = json.loads(result["body"])  # Parse JSON string
                    assert body["totalAccounts"] == 1
                    assert body["serversExtended"] == 2
                    assert "timestamp" in body
    
                    # Verify active regions were used
                    mock_extend.assert_called_once()
                    call_args = mock_extend.call_args[0]
>                   assert call_args[1] == active_regions
E                   AssertionError: assert ['us-east-1',...-west-2', ...] == ['us-east-1', 'us-west-2']
E                     
E                     At index 1 diff: 'us-east-2' != 'us-west-2'
E                     Left contains 26 more items, first extra item: 'us-west-1'
E                     Use -v to get more diff

tests/unit/test_staging_account_sync_comprehensive.py:94: AssertionError
----------------------------- Captured stdout call -----------------------------
Starting auto-extend of staging account servers...
Staging account sync scanning 28 active regions (skipping 0 inactive)
Found 1 target accounts
------------------------------ Captured log call -------------------------------
ERROR    shared.active_region_filter:active_region_filter.py:193 DynamoDB error querying region status table: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
WARNING  shared.active_region_filter:active_region_filter.py:194 Falling back to all DRS regions
_____ TestGetStagingAccountServers.test_uses_inventory_database_when_fresh _____

self = <tests.unit.test_staging_account_sync_comprehensive.TestGetStagingAccountServers object at 0x10deb0bc0>

    def test_uses_inventory_database_when_fresh(self):
        """Test that inventory database is used when data is fresh."""
        active_regions = ["us-east-1", "us-west-2"]
        servers = [{"sourceServerID": "s-123", "arn": "arn:aws:drs:us-east-1:123:source-server/s-123"}]
    
        with patch.object(inventory_query, "is_inventory_fresh") as mock_is_fresh:
            with patch.object(inventory_query, "query_inventory_by_staging_account") as mock_query:
                # Setup: Fresh inventory
                mock_is_fresh.return_value = True
                mock_query.return_value = servers
    
                # Execute
                result = dm_handler.get_staging_account_servers(
                    staging_account_id="987654321098",
                    role_arn="arn:aws:iam::987654321098:role/StagingRole",
                    external_id="ext123",
                    active_regions=active_regions,
                )
    
                # Verify
>               assert result == servers
E               AssertionError: assert [] == [{'arn': 'arn...ID': 's-123'}]
E                 
E                 Right contains one more item: {'arn': 'arn:aws:drs:us-east-1:123:source-server/s-123', 'sourceServerID': 's-123'}
E                 Use -v to get more diff

tests/unit/test_staging_account_sync_comprehensive.py:423: AssertionError
----------------------------- Captured stdout call -----------------------------
Querying DRS API for staging account 987654321098 across 2 active regions
Error getting account ID: An error occurred (InvalidClientTokenId) when calling the GetCallerIdentity operation: The security token included in the request is invalid.
Failed to assume role for staging 987654321098: An error occurred (InvalidClientTokenId) when calling the AssumeRole operation: The security token included in the request is invalid.
------------------------------ Captured log call -------------------------------
ERROR    shared.inventory_query:inventory_query.py:174 DynamoDB error checking inventory freshness: An error occurred (UnrecognizedClientException) when calling the Scan operation: The security token included in the request is invalid.
=============================== warnings summary ===============================
tests/unit/test_cross_account_audit.py::TestCrossAccountDRSQueryAuditLogging::test_cross_account_query_audit_log_fields
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:114: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestCrossAccountDRSQueryAuditLogging::test_cross_account_query_with_sts_assume_role
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:175: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestHubAndSpokeAuditTrail::test_hub_account_audit_log_aggregation
tests/unit/test_cross_account_audit.py::TestHubAndSpokeAuditTrail::test_hub_account_audit_log_aggregation
tests/unit/test_cross_account_audit.py::TestHubAndSpokeAuditTrail::test_hub_account_audit_log_aggregation
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:212: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestSourceAndTargetAccountFields::test_source_account_is_hub_account
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:292: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestSourceAndTargetAccountFields::test_target_account_from_event_parameter
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:318: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestSourceAndTargetAccountFields::test_same_account_query_has_matching_source_and_target
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:350: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestAssumedRoleAndSessionFields::test_assumed_role_arn_for_cross_account_query
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:386: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestAssumedRoleAndSessionFields::test_cross_account_session_name_populated
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:417: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestAssumedRoleAndSessionFields::test_null_assumed_role_for_same_account_query
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:452: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestCentralizedAuditTrail::test_hub_account_audit_table_receives_all_logs
tests/unit/test_cross_account_audit.py::TestCentralizedAuditTrail::test_hub_account_audit_table_receives_all_logs
tests/unit/test_cross_account_audit.py::TestCentralizedAuditTrail::test_hub_account_audit_table_receives_all_logs
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:642: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_cross_account_audit.py::TestCentralizedAuditTrail::test_audit_log_retention_and_encryption
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/test_cross_account_audit.py:668: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

tests/unit/test_execution_orchestration_handlers.py::TestCallbackHandlerResume::test_resume_calls_send_task_success
tests/unit/test_execution_orchestration_handlers.py::TestExpiredTokenHandling::test_invalid_token_exception_returns_400
tests/unit/test_execution_orchestration_handlers.py::TestExpiredTokenHandling::test_task_does_not_exist_returns_400
  /Users/jocousen/Documents/CODE/GITHUB/aws-elasticdrs-orchestrator/tests/unit/../../lambda/execution-handler/index.py:7911: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
============================ Hypothesis Statistics =============================
tests/unit/test_account_breakdown_completeness_property.py::test_property_12_account_breakdown_completeness:

  - during generate phase (2.85 seconds):
    - Typical runtimes: ~ 0-77 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 10 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_account_consistency_property.py::test_property_mixed_accounts_rejected:

  - during generate phase (1.41 seconds):
    - Typical runtimes: ~ 4-15 ms, of which ~ 4-13 ms in data generation
    - 100 passing examples, 0 failing examples, 38 invalid examples
    - Events:
      * 14.49%, invalid because: failed to satisfy assume() in test_property_mixed_accounts_rejected (line 278)
      * 2.17%, invalid because: failed to satisfy assume() in mixed_account_pg_list_strategy (line 95)

  - Stopped because settings.max_examples=100


tests/unit/test_account_consistency_property.py::test_property_same_account_accepted:

  - during generate phase (1.17 seconds):
    - Typical runtimes: ~ 2-10 ms, of which ~ 2-9 ms in data generation
    - 100 passing examples, 0 failing examples, 48 invalid examples
    - Events:
      * 16.22%, invalid because: failed to satisfy assume() in test_property_same_account_accepted (line 330)

  - Stopped because settings.max_examples=100


tests/unit/test_account_utils_property.py::test_property_arn_construction_pattern:

  - during generate phase (0.02 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_account_utils_property.py::test_property_account_id_extraction_inverse:

  - during generate phase (0.02 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_account_utils_property.py::test_property_extraction_works_for_any_role_name:

  - during generate phase (0.10 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 7 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_account_utils_property.py::test_property_validation_rejects_invalid_formats:

  - during generate phase (0.09 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 20 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_account_utils_property.py::test_property_account_id_format_validation:

  - during generate phase (0.06 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 200 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=200


tests/unit/test_account_utils_property.py::test_property_invocation_source_detection:

  - during generate phase (0.34 seconds):
    - Typical runtimes: ~ 0-1 ms, of which ~ 0-1 ms in data generation
    - 200 passing examples, 0 failing examples, 47 invalid examples

  - Stopped because settings.max_examples=200


tests/unit/test_account_utils_property.py::test_property_invocation_source_direct_no_request_context:

  - during generate phase (0.15 seconds):
    - Typical runtimes: ~ 0-1 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 41 invalid examples
    - Events:
      * 36.88%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(lambda k: k != "requestContext").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_account_utils_property.py::test_property_direct_invocation_requires_account_id:

  - during generate phase (0.07 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 200 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=200


tests/unit/test_account_utils_property.py::test_property_direct_invocation_with_valid_account_succeeds:

  - during generate phase (0.12 seconds):
    - Typical runtimes: ~ 0-1 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_active_region_filtering_property.py::test_property_active_region_filtering_consistency:

  - during generate phase (9.38 seconds):
    - Typical runtimes: ~ 1-193 ms, of which ~ 0-3 ms in data generation
    - 100 passing examples, 0 failing examples, 4 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_active_region_filtering_property.py::test_property_active_region_filtering_with_pagination:

  - during generate phase (9.29 seconds):
    - Typical runtimes: ~ 2-197 ms, of which ~ 0-3 ms in data generation
    - 100 passing examples, 0 failing examples, 3 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_active_region_filtering_property.py::test_property_active_region_filtering_cache_behavior:

  - during generate phase (4.43 seconds):
    - Typical runtimes: ~ 0-195 ms, of which ~ 0-3 ms in data generation
    - 50 passing examples, 0 failing examples, 6 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_active_region_filtering_property.py::test_property_active_region_filtering_cache_expiry:

  - during generate phase (64.77 seconds):
    - Typical runtimes: ~ 1103-1390 ms, of which ~ 0-3 ms in data generation
    - 50 passing examples, 0 failing examples, 2 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_active_region_filtering_property.py::test_property_fallback_to_all_regions:

  - during generate phase (0.02 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 33 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_active_region_filtering_property.py::test_property_fallback_handles_all_dynamodb_errors:

  - during generate phase (0.00 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 5 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_active_region_filtering_property.py::test_property_fallback_handles_unexpected_exceptions:

  - during generate phase (0.00 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 4 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_active_region_filtering_property.py::test_property_fallback_consistency_across_calls:

  - during generate phase (5.75 seconds):
    - Typical runtimes: ~ 0-505 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_active_region_filtering_property.py::test_property_fallback_recovery_after_table_populated:

  - during generate phase (4.84 seconds):
    - Typical runtimes: ~ 0-190 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 34 invalid examples
    - Events:
      * 58.33%, Retried draw from FixedKeysDictStrategy(('region', 'serverCount'), TupleStrategy((sampled_from(['us-east-1', 'us-east-2', 'us-west-1', 'us-west-2', 'eu-west-1', 'eu-west-2', 'eu-west-3', 'eu-central-1', 'eu-central-2', 'eu-north-1', 'eu-south-1', 'eu-south-2', 'ap-east-1', 'ap-south-1', 'ap-south-2', 'ap-southeast-1', 'ap-southeast-2', 'ap-southeast-3', 'ap-southeast-4', 'ap-northeast-1', 'ap-northeast-2', 'ap-northeast-3', 'me-south-1', 'me-central-1', 'af-south-1', 'il-central-1', 'ca-central-1', 'sa-east-1']), integers(min_value=1, max_value=100)))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_active_region_tag_sync_property.py::test_property_tag_sync_uses_active_region_filtering:

  - during generate phase (0.06 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 6 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_active_region_tag_sync_property.py::test_property_tag_sync_region_count_matches:

  - during generate phase (0.03 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 6 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_active_region_tag_sync_property.py::test_property_tag_sync_skips_inactive_regions:

  - during generate phase (0.04 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_active_region_tag_sync_property.py::test_property_tag_sync_api_call_reduction:

  - during generate phase (0.03 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 24 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_aws_approved_fields_property.py::test_allowed_fields_accepted:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_aws_approved_fields_property.py::test_blocked_fields_rejected:

  - during generate phase (0.00 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_aws_approved_fields_property.py::test_mixed_fields_rejected:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_aws_approved_fields_property.py::test_unknown_fields_handling:

  - during generate phase (0.00 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_callback_handler_property.py::test_property_validate_task_token_rejects_short:

  - during generate phase (0.08 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 200 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=200


tests/unit/test_callback_handler_property.py::test_property_callback_handler_rejects_short_token:

  - during generate phase (0.10 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 200 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=200


tests/unit/test_callback_handler_property.py::test_property_empty_token_rejected:

  - during generate phase (0.00 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 2 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_callback_handler_property.py::test_property_whitespace_only_token_rejected:

  - during generate phase (0.00 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 2 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_cli_operation_response_structure_property.py::test_property_add_staging_account_response_structure:

  - during generate phase (0.69 seconds):
    - Typical runtimes: ~ 4-6 ms, of which ~ 1-3 ms in data generation
    - 100 passing examples, 0 failing examples, 5 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_cli_operation_response_structure_property.py::test_property_remove_staging_account_response_structure:

  - during generate phase (1.35 seconds):
    - Typical runtimes: ~ 2-25 ms, of which ~ 2-12 ms in data generation
    - 100 passing examples, 0 failing examples, 16 invalid examples
    - Events:
      * 3.45%, Retried draw from FixedKeysDictStrategy(('accountId', 'accountName', 'roleArn', 'externalId'), TupleStrategy((from_regex('\\d{12}', fullmatch=True), text(alphabet=characters(whitelist_categories=('Lu', 'Ll', 'Nd'), whitelist_characters='_-'), min_size=1, max_size=50), builds(lambda acc_id: f"arn:aws:iam::{acc_id}:role/TestRole", from_regex('\\d{12}', fullmatch=True)), text(min_size=1, max_size=100)))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_cli_operation_response_structure_property.py::test_property_validate_staging_account_response_structure:

  - during generate phase (0.72 seconds):
    - Typical runtimes: ~ 1-13 ms, of which ~ 1-3 ms in data generation
    - 100 passing examples, 0 failing examples, 10 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_cli_operation_response_structure_property.py::test_property_error_responses_have_descriptive_messages:

  - during generate phase (0.08 seconds):
    - Typical runtimes: ~ 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_combined_capacity_aggregation_property.py::test_property_combined_capacity_aggregation:

  - during generate phase (1.29 seconds):
    - Typical runtimes: ~ 2-18 ms, of which ~ 1-16 ms in data generation
    - 100 passing examples, 0 failing examples, 5 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_combined_capacity_aggregation_property.py::test_property_uniform_capacity_distribution:

  - during generate phase (0.06 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_combined_capacity_aggregation_property.py::test_property_inaccessible_accounts_excluded:

  - during generate phase (1.17 seconds):
    - Typical runtimes: ~ 1-17 ms, of which ~ 1-15 ms in data generation
    - 100 passing examples, 0 failing examples, 5 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_config_merge_property.py::test_configuration_merge_correctness:

  - during generate phase (0.02 seconds):
    - Typical runtimes: ~ 0-2 ms, of which ~ 0-2 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_config_merge_property.py::test_no_server_config_returns_group_defaults:

  - during generate phase (0.01 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_config_merge_property.py::test_merge_idempotence:

  - during generate phase (0.01 seconds):
    - Typical runtimes: ~ 0-1 ms, of which ~ 0-1 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_data_management_operations_property.py::test_property_valid_operation_routing_succeeds:

  - during generate phase (1.70 seconds):
    - Typical runtimes: ~ 5-122 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_invalid_operation_returns_error:

  - during generate phase (0.74 seconds):
    - Typical runtimes: ~ 0-6 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 12 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_protection_group_operations_route_correctly:

  - during generate phase (0.80 seconds):
    - Typical runtimes: ~ 4-6 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_recovery_plan_operations_route_correctly:

  - during generate phase (0.72 seconds):
    - Typical runtimes: ~ 4-6 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_server_launch_config_operations_route_correctly:

  - during generate phase (0.69 seconds):
    - Typical runtimes: ~ 4-6 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_target_account_operations_route_correctly:

  - during generate phase (0.69 seconds):
    - Typical runtimes: ~ 4-6 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_tag_sync_operations_route_correctly:

  - during generate phase (0.03 seconds):
    - Typical runtimes: ~ 4-5 ms, of which < 1ms in data generation
    - 5 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_data_management_operations_property.py::test_property_staging_account_operations_route_correctly:

  - during generate phase (2.73 seconds):
    - Typical runtimes: ~ 4-126 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_import_configuration_routes_correctly:

  - during generate phase (0.00 seconds):
    - Typical runtimes: ~ 4ms, of which < 1ms in data generation
    - 1 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_data_management_operations_property.py::test_property_error_response_structure_consistency:

  - during generate phase (0.74 seconds):
    - Typical runtimes: ~ 0-6 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 10 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_missing_operation_returns_error:

  - during generate phase (0.78 seconds):
    - Typical runtimes: ~ 0-6 ms, of which ~ 0-2 ms in data generation
    - 100 passing examples, 0 failing examples, 55 invalid examples
    - Events:
      * 50.97%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc'))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_all_operations_return_dict:

  - during generate phase (1.28 seconds):
    - Typical runtimes: ~ 5-76 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_data_management_operations_property.py::test_property_response_format_no_api_gateway_wrapping:

  - during generate phase (7.77 seconds):
    - Typical runtimes: ~ 4-164 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_empty_staging_accounts_default_property.py::test_property_13_empty_staging_accounts_default:

  - during generate phase (2.62 seconds):
    - Typical runtimes: ~ 17-96 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_empty_staging_accounts_default_property.py::test_property_13_missing_staging_accounts_attribute:

  - during generate phase (1.50 seconds):
    - Typical runtimes: ~ 17-95 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_error_handling_property.py::TestErrorResponseStructureProperty::test_invalid_operation_error_structure_consistent:

  - during generate phase (0.05 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_error_handling_property.py::TestErrorResponseStructureProperty::test_missing_operation_field_error_consistent:

  - during generate phase (0.00 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_error_handling_property.py::TestErrorResponseStructureProperty::test_authorization_failure_error_consistent:

  - during generate phase (0.00 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_error_handling_property.py::TestDynamoDBErrorConsistencyProperty::test_dynamodb_error_structure_consistent:

  - during generate phase (0.80 seconds):
    - Typical runtimes: ~ 0-168 ms, of which < 1ms in data generation
    - 18 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_error_handling_property.py::TestDRSErrorConsistencyProperty::test_drs_error_structure_consistent:

  - during generate phase (0.53 seconds):
    - Typical runtimes: ~ 0-136 ms, of which < 1ms in data generation
    - 18 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_error_handling_property.py::TestUnexpectedExceptionConsistencyProperty::test_unexpected_exception_error_consistent:

  - during generate phase (0.19 seconds):
    - Typical runtimes: ~ 37-109 ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_error_handling_property.py::TestMissingParameterConsistencyProperty::test_missing_parameter_error_consistent_across_handlers:

  - during generate phase (0.04 seconds):
    - Typical runtimes: ~ 0-43 ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_error_handling_property.py::TestNotFoundErrorConsistencyProperty::test_not_found_error_consistent_across_handlers:

  - during generate phase (0.18 seconds):
    - Typical runtimes: ~ 3-131 ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_error_handling_property.py::TestErrorResponseJSONSerializability::test_all_error_responses_json_serializable:

  - during generate phase (0.01 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 12 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_execution_handler_direct_invocation_property.py::test_property_valid_operation_routing_succeeds:

  - during generate phase (1.56 seconds):
    - Typical runtimes: ~ 6-79 ms, of which ~ 0-3 ms in data generation
    - 100 passing examples, 0 failing examples, 4 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_execution_handler_direct_invocation_property.py::test_property_invalid_operation_returns_error:

  - during generate phase (1.16 seconds):
    - Typical runtimes: ~ 0-77 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 11 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_execution_handler_direct_invocation_property.py::test_property_operation_with_required_params_routes_correctly:

  - during generate phase (1.31 seconds):
    - Typical runtimes: ~ 6-79 ms, of which ~ 0-3 ms in data generation
    - 100 passing examples, 0 failing examples, 2 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_execution_handler_direct_invocation_property.py::test_property_response_format_no_api_gateway_wrapping:

  - during generate phase (1.46 seconds):
    - Typical runtimes: ~ 6-85 ms, of which ~ 0-3 ms in data generation
    - 100 passing examples, 0 failing examples, 7 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_execution_handler_direct_invocation_property.py::test_property_error_response_structure_consistency:

  - during generate phase (1.26 seconds):
    - Typical runtimes: ~ 0-81 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 8 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_execution_handler_direct_invocation_property.py::test_property_missing_operation_returns_error:

  - during generate phase (1.32 seconds):
    - Typical runtimes: ~ 0-9 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 50 invalid examples
    - Events:
      * 55.33%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc'))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_execution_handler_direct_invocation_property.py::test_property_all_operations_return_dict:

  - during generate phase (1.54 seconds):
    - Typical runtimes: ~ 6-84 ms, of which ~ 0-4 ms in data generation
    - 100 passing examples, 0 failing examples, 7 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_failed_account_resilience_property.py::test_property_failed_account_resilience:

  - during generate phase (15.33 seconds):
    - Typical runtimes: ~ 1-254 ms, of which ~ 1-9 ms in data generation
    - 100 passing examples, 0 failing examples, 112 invalid examples
    - Events:
      * 44.34%, Retried draw from <hypothesis.strategies._internal.core.CompositeStrategy object at 0x12b5ea420>.filter(re.compile('\\d{12}').fullmatch).filter(not_yet_in_unique_list) to satisfy filter
      * 5.66%, invalid because: Aborted test because unable to satisfy <hypothesis.strategies._internal.core.CompositeStrategy object at 0x12b5ea420>.filter(re.compile('\\d{12}').fullmatch).filter(not_yet_in_unique_list)

  - Stopped because settings.max_examples=100


tests/unit/test_failed_account_resilience_property.py::test_property_partial_failure_continues_query:

  - during generate phase (6.25 seconds):
    - Typical runtimes: ~ 112-310 ms, of which < 1ms in data generation
    - 35 passing examples, 0 failing examples, 10 invalid examples
    - Events:
      * 22.22%, invalid because: failed to satisfy assume() in test_property_partial_failure_continues_query (line 211)

  - Stopped because nothing left to do


tests/unit/test_failed_account_resilience_property.py::test_property_all_staging_accounts_fail_target_succeeds:

  - during generate phase (1.35 seconds):
    - Typical runtimes: ~ 113-303 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_iam_audit_logging_property.py::test_audit_log_always_contains_required_fields:

  - during generate phase (0.12 seconds):
    - Typical runtimes: ~ 0-2 ms, of which ~ 0-2 ms in data generation
    - 50 passing examples, 0 failing examples, 9 invalid examples
    - Events:
      * 22.03%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_audit_log_timestamp_format:

  - during generate phase (0.16 seconds):
    - Typical runtimes: ~ 0-4 ms, of which ~ 0-3 ms in data generation
    - 50 passing examples, 0 failing examples, 12 invalid examples
    - Events:
      * 16.13%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_sensitive_params_always_masked:

  - during generate phase (0.09 seconds):
    - Typical runtimes: ~ 0-1 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 31 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_non_sensitive_params_not_masked:

  - during generate phase (0.08 seconds):
    - Typical runtimes: ~ 0-1 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 13 invalid examples
    - Events:
      * 46.03%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(lambda x: not any(sensitive in x.lower() for sensitive in ["password", "secret", "token", "key", "credential"])).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_large_results_always_truncated:

  - during generate phase (0.59 seconds):
    - Typical runtimes: ~ 1-12 ms, of which ~ 0-11 ms in data generation
    - 50 passing examples, 0 failing examples, 22 invalid examples
    - Events:
      * 59.72%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list) to satisfy filter
      * 8.33%, invalid because: Aborted test because unable to satisfy text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list)

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_small_results_not_truncated:

  - during generate phase (0.02 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 6 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_success_logs_use_info_level:

  - during generate phase (0.16 seconds):
    - Typical runtimes: ~ 0-3 ms, of which ~ 0-3 ms in data generation
    - 50 passing examples, 0 failing examples, 17 invalid examples
    - Events:
      * 26.87%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_failure_logs_use_warning_level:

  - during generate phase (0.15 seconds):
    - Typical runtimes: ~ 0-3 ms, of which ~ 0-2 ms in data generation
    - 50 passing examples, 0 failing examples, 26 invalid examples
    - Events:
      * 31.58%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_audit_log_with_context_includes_metadata:

  - during generate phase (0.14 seconds):
    - Typical runtimes: ~ 0-3 ms, of which ~ 0-2 ms in data generation
    - 50 passing examples, 0 failing examples, 11 invalid examples
    - Events:
      * 27.87%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_audit_log_json_parseable:

  - during generate phase (0.15 seconds):
    - Typical runtimes: ~ 0-3 ms, of which ~ 0-3 ms in data generation
    - 50 passing examples, 0 failing examples, 8 invalid examples
    - Events:
      * 18.97%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_audit_logging_property.py::test_nested_sensitive_params_masked:

  - during generate phase (0.12 seconds):
    - Typical runtimes: ~ 0-5 ms, of which ~ 0-5 ms in data generation
    - 30 passing examples, 0 failing examples, 3 invalid examples
    - Events:
      * 9.09%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=30


tests/unit/test_iam_audit_logging_property.py::test_audit_log_event_type_always_direct_invocation:

  - during generate phase (0.21 seconds):
    - Typical runtimes: ~ 0-2 ms, of which ~ 0-2 ms in data generation
    - 50 passing examples, 0 failing examples, 17 invalid examples
    - Events:
      * 13.43%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=30).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_orchestration_role_always_authorized:

  - during generate phase (0.08 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 61 invalid examples
    - Events:
      * 50.45%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha()) to satisfy filter
      * 11.71%, invalid because: Aborted test because unable to satisfy text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha())

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_assumed_orchestration_role_always_authorized:

  - during generate phase (0.07 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 33 invalid examples
    - Events:
      * 30.12%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha()) to satisfy filter
      * 7.23%, invalid because: Aborted test because unable to satisfy text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha())

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_step_functions_role_always_authorized:

  - during generate phase (0.07 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 41 invalid examples
    - Events:
      * 46.15%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha()) to satisfy filter
      * 6.59%, invalid because: Aborted test because unable to satisfy text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha())

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_lambda_role_always_authorized:

  - during generate phase (0.07 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 46 invalid examples
    - Events:
      * 46.88%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha()) to satisfy filter
      * 6.25%, invalid because: Aborted test because unable to satisfy text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha())

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_admin_user_always_authorized:

  - during generate phase (0.04 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 3 invalid examples
    - Events:
      * 7.55%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_+=,.@'), min_size=1, max_size=64).filter(lambda x: x[0].isalnum()) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_random_role_without_keywords_denied:

  - during generate phase (0.07 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 42 invalid examples
    - Events:
      * 46.74%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha()) to satisfy filter
      * 6.52%, invalid because: Aborted test because unable to satisfy text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha())

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_random_user_without_admin_denied:

  - during generate phase (0.04 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 3 invalid examples
    - Events:
      * 7.55%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_+=,.@'), min_size=1, max_size=64).filter(lambda x: x[0].isalnum()) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_malformed_arn_always_denied:

  - during generate phase (0.02 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_empty_and_unknown_principals_denied:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_lambda_function_arn_always_authorized:

  - during generate phase (0.07 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 47 invalid examples
    - Events:
      * 46.39%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha()) to satisfy filter
      * 6.19%, invalid because: Aborted test because unable to satisfy text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha())

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_service_role_always_authorized:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_authorization_case_insensitive:

  - during generate phase (0.07 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 45 invalid examples
    - Events:
      * 50.53%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha()) to satisfy filter
      * 7.37%, invalid because: Aborted test because unable to satisfy text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha())

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_extract_principal_from_context:

  - during generate phase (0.07 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 46 invalid examples
    - Events:
      * 45.83%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha()) to satisfy filter
      * 6.25%, invalid because: Aborted test because unable to satisfy text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha())

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_valid_direct_invocation_event:

  - during generate phase (0.07 seconds):
    - Typical runtimes: ~ 0-2 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 14 invalid examples
    - Events:
      * 31.25%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=50).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_invalid_direct_invocation_event_without_operation:

  - during generate phase (0.10 seconds):
    - Typical runtimes: ~ 0-2 ms, of which ~ 0-2 ms in data generation
    - 50 passing examples, 0 failing examples, 17 invalid examples
    - Events:
      * 37.31%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc')), min_size=1, max_size=50).filter(lambda x: x != "operation").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_iam_utils_property.py::test_invalid_direct_invocation_event_with_empty_operation:

  - during generate phase (0.00 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_iam_utils_property.py::test_authorization_deterministic:

  - during generate phase (0.04 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 19 invalid examples
    - Events:
      * 36.23%, Retried draw from text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha()) to satisfy filter
      * 8.70%, invalid because: Aborted test because unable to satisfy text(characters(categories=(), include_characters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'), min_size=1, max_size=64).filter(lambda x: x[0].isalpha())

  - Stopped because settings.max_examples=50


tests/unit/test_inventory_fallback_property.py::test_property_10_inventory_updated_during_fallback:

  - during reuse phase (0.50 seconds):
    - Typical runtimes: ~ 500ms, of which ~ 2ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_fallback_property.py::test_property_10_no_update_when_inventory_fresh:

  - during generate phase (92.96 seconds):
    - Typical runtimes: ~ 0-1652 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 22 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_inventory_fallback_property.py::test_property_10_no_update_when_update_on_fallback_false:

  - during generate phase (6.64 seconds):
    - Typical runtimes: ~ 4-65 ms, of which ~ 1-6 ms in data generation
    - 100 passing examples, 0 failing examples, 8 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_inventory_fallback_property.py::test_property_13_topology_preserved_on_update:

  - during reuse phase (0.05 seconds):
    - Typical runtimes: ~ 52ms, of which ~ 2ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_fallback_property.py::test_property_13_topology_captured_for_new_server:

  - during reuse phase (0.05 seconds):
    - Typical runtimes: ~ 49ms, of which ~ 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_fallback_property.py::test_property_13_get_failback_topology_returns_correct_data:

  - during reuse phase (0.05 seconds):
    - Typical runtimes: ~ 50ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_fallback_property.py::test_property_13_get_failback_topology_handles_missing_server:

  - during generate phase (5.13 seconds):
    - Typical runtimes: ~ 35-125 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_inventory_fallback_property.py::test_property_13_get_failback_topology_handles_missing_topology:

  - during generate phase (4.27 seconds):
    - Typical runtimes: ~ 35-49 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_inventory_query_property.py::test_property_inventory_freshness_check:

  - during reuse phase (0.04 seconds):
    - Typical runtimes: ~ 41ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_query_property.py::test_property_custom_freshness_threshold:

  - during reuse phase (0.04 seconds):
    - Typical runtimes: ~ 37ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_query_property.py::test_property_stale_inventory_returns_empty:

  - during reuse phase (0.04 seconds):
    - Typical runtimes: ~ 35ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_query_property.py::test_property_inventory_data_completeness:

  - during reuse phase (0.11 seconds):
    - Typical runtimes: ~ 44-63 ms, of which ~ 0-1 ms in data generation
    - 0 passing examples, 2 failing examples, 0 invalid examples
    - Found 2 distinct errors in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_query_property.py::test_property_all_servers_have_required_fields:

  - during reuse phase (0.05 seconds):
    - Typical runtimes: ~ 47ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_sync_property.py::test_property_region_status_table_updates:

  - during reuse phase (0.01 seconds):
    - Typical runtimes: ~ 11ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_sync_property.py::test_property_region_status_update_idempotency:

  - during reuse phase (0.01 seconds):
    - Typical runtimes: ~ 5ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_sync_property.py::test_property_region_status_update_overwrites_previous:

  - during reuse phase (0.01 seconds):
    - Typical runtimes: ~ 8ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_inventory_sync_property.py::test_property_cache_invalidation_after_inventory_sync:

  - during generate phase (24.47 seconds):
    - Typical runtimes: ~ 0-383 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 31 invalid examples
    - Events:
      * 64.12%, Retried draw from FixedKeysDictStrategy(('region', 'serverCount'), TupleStrategy((sampled_from(['us-east-1', 'us-east-2', 'us-west-1', 'us-west-2', 'eu-west-1', 'eu-west-2', 'eu-west-3', 'eu-central-1', 'eu-central-2', 'eu-north-1', 'eu-south-1', 'eu-south-2', 'ap-east-1', 'ap-south-1', 'ap-south-2', 'ap-southeast-1', 'ap-southeast-2', 'ap-southeast-3', 'ap-southeast-4', 'ap-northeast-1', 'ap-northeast-2', 'ap-northeast-3', 'me-south-1', 'me-central-1', 'af-south-1', 'il-central-1', 'ca-central-1', 'sa-east-1']), integers(min_value=1, max_value=100)))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_inventory_sync_property.py::test_property_cache_invalidation_clears_all_cached_data:

  - during generate phase (9.64 seconds):
    - Typical runtimes: ~ 0-269 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 36 invalid examples
    - Events:
      * 67.44%, Retried draw from FixedKeysDictStrategy(('region', 'serverCount'), TupleStrategy((sampled_from(['us-east-1', 'us-east-2', 'us-west-1', 'us-west-2', 'eu-west-1', 'eu-west-2', 'eu-west-3', 'eu-central-1', 'eu-central-2', 'eu-north-1', 'eu-south-1', 'eu-south-2', 'ap-east-1', 'ap-south-1', 'ap-south-2', 'ap-southeast-1', 'ap-southeast-2', 'ap-southeast-3', 'ap-southeast-4', 'ap-northeast-1', 'ap-northeast-2', 'ap-northeast-3', 'me-south-1', 'me-central-1', 'af-south-1', 'il-central-1', 'ca-central-1', 'sa-east-1']), integers(min_value=1, max_value=100)))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_inventory_sync_property.py::test_property_cache_invalidation_idempotent:

  - during generate phase (9.79 seconds):
    - Typical runtimes: ~ 0-271 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 36 invalid examples
    - Events:
      * 65.12%, Retried draw from FixedKeysDictStrategy(('region', 'serverCount'), TupleStrategy((sampled_from(['us-east-1', 'us-east-2', 'us-west-1', 'us-west-2', 'eu-west-1', 'eu-west-2', 'eu-west-3', 'eu-central-1', 'eu-central-2', 'eu-north-1', 'eu-south-1', 'eu-south-2', 'ap-east-1', 'ap-south-1', 'ap-south-2', 'ap-southeast-1', 'ap-southeast-2', 'ap-southeast-3', 'ap-southeast-4', 'ap-northeast-1', 'ap-northeast-2', 'ap-northeast-3', 'me-south-1', 'me-central-1', 'af-south-1', 'il-central-1', 'ca-central-1', 'sa-east-1']), integers(min_value=1, max_value=100)))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_launch_config_schema_property.py::TestProperty4StatusSchemaValidity::test_property_4_status_field_is_valid:

  - during generate phase (0.07 seconds):
    - Typical runtimes: ~ 0-25 ms, of which ~ 0-24 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_schema_property.py::TestProperty4StatusSchemaValidity::test_property_4_last_applied_present_when_configured:

  - during generate phase (0.09 seconds):
    - Typical runtimes: ~ 0-16 ms, of which ~ 0-15 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_schema_property.py::TestProperty4StatusSchemaValidity::test_property_4_not_configured_has_null_timestamp:

  - during generate phase (0.09 seconds):
    - Typical runtimes: ~ 0-16 ms, of which ~ 0-16 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_schema_property.py::TestProperty4StatusSchemaValidity::test_property_4_required_fields_present:

  - during generate phase (0.06 seconds):
    - Typical runtimes: ~ 0-13 ms, of which ~ 0-12 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_schema_property.py::TestProperty4StatusSchemaValidity::test_property_4_server_configs_is_dict:

  - during generate phase (0.08 seconds):
    - Typical runtimes: ~ 0-17 ms, of which ~ 0-16 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_schema_property.py::TestProperty4StatusSchemaValidity::test_property_4_errors_is_list:

  - during generate phase (0.08 seconds):
    - Typical runtimes: ~ 0-16 ms, of which ~ 0-15 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_schema_property.py::TestProperty4StatusSchemaValidity::test_property_4_camel_case_field_names:

  - during generate phase (0.08 seconds):
    - Typical runtimes: ~ 0-15 ms, of which ~ 0-14 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_schema_property.py::TestProperty4StatusSchemaValidity::test_property_4_server_status_is_valid:

  - during generate phase (0.07 seconds):
    - Typical runtimes: ~ 0-12 ms, of which ~ 0-12 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_schema_property.py::TestProperty4StatusSchemaValidity::test_property_4_config_hash_format:

  - during generate phase (0.09 seconds):
    - Typical runtimes: ~ 0-14 ms, of which ~ 0-13 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty1ConfigurationApplicationCompleteness::test_property_1_all_servers_processed:

  - during generate phase (3.71 seconds):
    - Typical runtimes: ~ 114-1128 ms, of which ~ 0-1 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples
    - Events:
      * 10.00%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty1ConfigurationApplicationCompleteness::test_property_1_status_persisted:

  - during generate phase (3.49 seconds):
    - Typical runtimes: ~ 109-589 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty1ConfigurationApplicationCompleteness::test_property_1_config_hash_calculated:

  - during generate phase (5.00 seconds):
    - Typical runtimes: ~ 126-1056 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty1ConfigurationApplicationCompleteness::test_property_1_partial_success_handling:

  - during generate phase (4.83 seconds):
    - Typical runtimes: ~ 1-944 ms, of which ~ 0-2 ms in data generation
    - 10 passing examples, 0 failing examples, 6 invalid examples
    - Events:
      * 37.50%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter
      * 37.50%, invalid because: Aborted test because unable to satisfy integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list)

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty10ConfigurationHashConsistency::test_property_10_hash_consistency_simple_dict:

  - during generate phase (0.02 seconds):
    - Typical runtimes: ~ 0-3 ms, of which ~ 0-3 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty10ConfigurationHashConsistency::test_property_10_hash_consistency_with_lists:

  - during generate phase (0.03 seconds):
    - Typical runtimes: ~ 0-7 ms, of which ~ 0-6 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty10ConfigurationHashConsistency::test_property_10_hash_consistency_nested_structures:

  - during generate phase (0.02 seconds):
    - Typical runtimes: ~ 0-6 ms, of which ~ 0-6 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty10ConfigurationHashConsistency::test_property_10_hash_independent_of_key_order:

  - during generate phase (0.02 seconds):
    - Typical runtimes: ~ 0-7 ms, of which ~ 0-6 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty10ConfigurationHashConsistency::test_property_10_hash_consistency_with_numeric_types:

  - during generate phase (0.02 seconds):
    - Typical runtimes: ~ 0-5 ms, of which ~ 0-5 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty10ConfigurationHashConsistency::test_property_10_hash_consistency_with_none_values:

  - during generate phase (0.02 seconds):
    - Typical runtimes: ~ 0-3 ms, of which ~ 0-3 ms in data generation
    - 10 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_status_field_validity:

  - during reuse phase (0.31 seconds):
    - Typical runtimes: ~ 304ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_timestamp_presence_for_configured_status:

  - during reuse phase (0.11 seconds):
    - Typical runtimes: ~ 111ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_server_configs_structure_validity:

  - during reuse phase (0.10 seconds):
    - Typical runtimes: ~ 101ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_not_configured_status_no_timestamp_required:

  - during reuse phase (0.11 seconds):
    - Typical runtimes: ~ 106ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_camelcase_naming_convention:

  - during reuse phase (0.10 seconds):
    - Typical runtimes: ~ 99ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty8ConfigurationDriftDetection::test_property_8_drift_detected_when_hashes_differ:

  - during generate phase (0.41 seconds):
    - Typical runtimes: ~ 32-47 ms, of which ~ 0-5 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty8ConfigurationDriftDetection::test_property_8_no_drift_when_hashes_match:

  - during reuse phase (0.09 seconds):
    - Typical runtimes: ~ 87ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty8ConfigurationDriftDetection::test_property_8_partial_drift_detection:

  - during reuse phase (0.09 seconds):
    - Typical runtimes: ~ 85ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty8ConfigurationDriftDetection::test_property_8_drift_with_missing_stored_config:

  - during reuse phase (0.08 seconds):
    - Typical runtimes: ~ 81ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty8ConfigurationDriftDetection::test_property_8_drift_with_not_configured_status:

  - during reuse phase (0.08 seconds):
    - Typical runtimes: ~ 80ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty9StatusUpdateAtomicity::test_property_9_all_fields_updated_together:

  - during generate phase (0.01 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty9StatusUpdateAtomicity::test_property_9_partial_update_not_allowed:

  - during generate phase (0.01 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty9StatusUpdateAtomicity::test_property_9_status_consistency_after_persist:

  - during generate phase (0.01 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty6ReapplyOperationCompleteness::test_property_6_all_servers_processed_on_reapply:

  - during generate phase (4.67 seconds):
    - Typical runtimes: ~ 126-1141 ms, of which ~ 0-2 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty6ReapplyOperationCompleteness::test_property_6_status_reflects_all_success:

  - during reuse phase (0.19 seconds):
    - Typical runtimes: ~ 187ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty6ReapplyOperationCompleteness::test_property_6_status_reflects_all_failure:

  - during generate phase (3.48 seconds):
    - Typical runtimes: ~ 109-984 ms, of which ~ 0-2 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty6ReapplyOperationCompleteness::test_property_6_status_reflects_partial_success:

  - during reuse phase (0.24 seconds):
    - Typical runtimes: ~ 236ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty6ReapplyOperationCompleteness::test_property_6_config_validation_before_application:

  - during generate phase (3.55 seconds):
    - Typical runtimes: ~ 118-896 ms, of which ~ 0-2 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty6ReapplyOperationCompleteness::test_property_6_reapply_updates_timestamps:

  - during reuse phase (0.17 seconds):
    - Typical runtimes: ~ 172ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty5ErrorVisibility::test_property_5_errors_captured_for_failed_servers:

  - during generate phase (4.61 seconds):
    - Typical runtimes: ~ 119-1201 ms, of which ~ 0-2 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty5ErrorVisibility::test_property_5_errors_in_overall_errors_array:

  - during generate phase (6.67 seconds):
    - Typical runtimes: ~ 1-1155 ms, of which ~ 1-3 ms in data generation
    - 10 passing examples, 0 failing examples, 6 invalid examples
    - Events:
      * 37.50%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter
      * 37.50%, invalid because: Aborted test because unable to satisfy integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list)

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty5ErrorVisibility::test_property_5_no_errors_for_successful_servers:

  - during generate phase (4.15 seconds):
    - Typical runtimes: ~ 118-983 ms, of which ~ 0-2 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty5ErrorVisibility::test_property_5_error_messages_are_descriptive:

  - during generate phase (3.12 seconds):
    - Typical runtimes: ~ 115-1014 ms, of which ~ 0-2 ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty5ErrorVisibility::test_property_5_errors_persist_in_dynamodb:

  - during generate phase (0.01 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=10


tests/unit/test_launch_config_service_property.py::TestProperty5ErrorVisibility::test_property_5_partial_failure_error_visibility:

  - during reuse phase (0.20 seconds):
    - Typical runtimes: ~ 198ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_ready_status_skips_config_application:

  - during reuse phase (0.10 seconds):
    - Typical runtimes: ~ 98ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_ready_status_has_valid_config_hashes:

  - during reuse phase (0.10 seconds):
    - Typical runtimes: ~ 99ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_non_ready_status_requires_config_application:

  - during reuse phase (0.10 seconds):
    - Typical runtimes: ~ 95ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_missing_status_requires_config_application:

  - during reuse phase (0.10 seconds):
    - Typical runtimes: ~ 94ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_fast_path_decision_is_deterministic:

  - during reuse phase (0.10 seconds):
    - Typical runtimes: ~ 100ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty11StatusTransitionValidity::test_property_11_apply_transitions_to_pending_first:

  - during generate phase (12.44 seconds):
    - Typical runtimes: ~ 0-355 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 24 invalid examples
    - Events:
      * 51.35%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_launch_config_service_property.py::TestProperty11StatusTransitionValidity::test_property_11_success_transitions_to_ready:

  - during reuse phase (0.21 seconds):
    - Typical runtimes: ~ 211ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_launch_config_service_property.py::TestProperty11StatusTransitionValidity::test_property_11_failure_transitions_to_failed:

  - during generate phase (11.64 seconds):
    - Typical runtimes: ~ 0-365 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 26 invalid examples
    - Events:
      * 48.68%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_launch_config_service_property.py::TestProperty11StatusTransitionValidity::test_property_11_partial_transitions_to_partial:

  - during generate phase (15.83 seconds):
    - Typical runtimes: ~ 0-541 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 28 invalid examples
    - Events:
      * 61.54%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter
      * 7.69%, invalid because: Aborted test because unable to satisfy integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list)

  - Stopped because settings.max_examples=50


tests/unit/test_launch_config_service_property.py::TestProperty11StatusTransitionValidity::test_property_11_reapply_from_any_final_state:

  - during generate phase (12.75 seconds):
    - Typical runtimes: ~ 0-377 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 26 invalid examples
    - Events:
      * 52.63%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_launch_config_service_property.py::TestProperty11StatusTransitionValidity::test_property_11_sequential_operations_valid_transitions:

  - during generate phase (22.28 seconds):
    - Typical runtimes: ~ 0-1617 ms, of which ~ 0-1 ms in data generation
    - 30 passing examples, 0 failing examples, 11 invalid examples
    - Events:
      * 36.59%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=30


tests/unit/test_launch_config_service_property.py::TestProperty12ConfigurationRoundTripPersistence::test_property_12_status_round_trip_preserves_all_fields:

  - during generate phase (0.18 seconds):
    - Typical runtimes: ~ 0-1 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 17 invalid examples
    - Events:
      * 44.78%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_launch_config_service_property.py::TestProperty12ConfigurationRoundTripPersistence::test_property_12_config_hash_preserved_exactly:

  - during generate phase (0.18 seconds):
    - Typical runtimes: ~ 0-3 ms, of which ~ 0-2 ms in data generation
    - 50 passing examples, 0 failing examples, 24 invalid examples
    - Events:
      * 40.54%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_launch_config_service_property.py::TestProperty12ConfigurationRoundTripPersistence::test_property_12_error_messages_preserved_exactly:

  - during generate phase (0.09 seconds):
    - Typical runtimes: ~ 0-2 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 20 invalid examples
    - Events:
      * 35.71%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_launch_config_service_property.py::TestProperty12ConfigurationRoundTripPersistence::test_property_12_timestamp_format_preserved:

  - during generate phase (0.09 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 25 invalid examples
    - Events:
      * 53.33%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_launch_config_service_property.py::TestProperty12ConfigurationRoundTripPersistence::test_property_12_multiple_persist_retrieve_cycles:

  - during generate phase (0.05 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 30 passing examples, 0 failing examples, 8 invalid examples
    - Events:
      * 28.95%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=30


tests/unit/test_launch_config_service_property.py::TestProperty12ConfigurationRoundTripPersistence::test_property_12_camelcase_field_names_preserved:

  - during generate phase (0.08 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 16 invalid examples
    - Events:
      * 50.00%, Retried draw from integers(0, 18446744073709551615).map(lambda i: f"s-{i:017x}").filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_multi_account_query_parallelism_property.py::test_property_multi_account_query_parallelism:

  - during reuse phase (0.28 seconds):
    - Typical runtimes: ~ 280ms, of which ~ 3ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_multi_account_query_parallelism_property.py::test_property_concurrent_region_queries_per_account:

  - during reuse phase (0.15 seconds):
    - Typical runtimes: ~ 153ms, of which < 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_multi_account_query_parallelism_property.py::test_property_parallel_execution_not_sequential:

  - during reuse phase (0.15 seconds):
    - Typical runtimes: ~ 149ms, of which ~ 1ms in data generation
    - 0 passing examples, 1 failing examples, 0 invalid examples
    - Found 1 distinct error in this phase

  - Stopped because nothing left to do


tests/unit/test_notification_formatter_property.py::test_property_formatter_output_contains_required_fields:

  - during generate phase (0.09 seconds):
    - Typical runtimes: ~ 0-1 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_notification_formatter_property.py::test_property_sns_publish_uses_structured_html:

  - during generate phase (0.12 seconds):
    - Typical runtimes: ~ 0-1 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_notifications_property.py::test_property_email_format_validation:

  - during generate phase (0.11 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 300 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=300


tests/unit/test_notifications_property.py::test_property_email_valid_format_accepted:

  - during generate phase (0.32 seconds):
    - Typical runtimes: ~ 0-3 ms, of which ~ 0-3 ms in data generation
    - 100 passing examples, 0 failing examples, 18 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_notifications_property.py::test_property_notification_delivery_all_event_types:

  - during generate phase (0.18 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 200 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=200


tests/unit/test_per_account_status_calculation_property.py::test_property_per_account_status_calculation:

  - during generate phase (0.03 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_per_account_status_calculation_property.py::test_property_ok_status_range:

  - during generate phase (0.03 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_per_account_status_calculation_property.py::test_property_info_status_range:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 25 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_per_account_status_calculation_property.py::test_property_warning_status_range:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 25 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_per_account_status_calculation_property.py::test_property_critical_status_range:

  - during generate phase (0.12 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 30 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_per_account_status_calculation_property.py::test_property_hyper_critical_status_range:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 21 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_query_handler_new_operations_property.py::test_property_get_staging_accounts_valid_account_returns_list:

  - during generate phase (1.92 seconds):
    - Typical runtimes: ~ 5-24 ms, of which ~ 1-17 ms in data generation
    - 100 passing examples, 0 failing examples, 4 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_query_handler_new_operations_property.py::test_property_get_staging_accounts_invalid_account_returns_error:

  - during generate phase (0.48 seconds):
    - Typical runtimes: ~ 3-5 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 3 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_query_handler_new_operations_property.py::test_property_get_staging_accounts_missing_parameter_returns_error:

  - during generate phase (0.99 seconds):
    - Typical runtimes: ~ 3-7 ms, of which ~ 0-3 ms in data generation
    - 100 passing examples, 0 failing examples, 50 invalid examples
    - Events:
      * 42.67%, Retried draw from text(characters(min_codepoint=65, categories=('Lu', 'Ll')), min_size=1, max_size=20).filter(lambda x: <unknown>).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_query_handler_new_operations_property.py::test_property_get_staging_accounts_not_found_returns_error:

  - during generate phase (0.58 seconds):
    - Typical runtimes: ~ 3-5 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_query_handler_new_operations_property.py::test_property_get_tag_sync_status_always_returns_structure:

  - during generate phase (0.63 seconds):
    - Typical runtimes: ~ 0-7 ms, of which ~ 0-3 ms in data generation
    - 100 passing examples, 0 failing examples, 47 invalid examples
    - Events:
      * 49.66%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc'))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_query_handler_new_operations_property.py::test_property_get_tag_sync_status_no_error_for_any_input:

  - during generate phase (0.76 seconds):
    - Typical runtimes: ~ 0-6 ms, of which ~ 0-3 ms in data generation
    - 100 passing examples, 0 failing examples, 49 invalid examples
    - Events:
      * 61.07%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc'))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_query_handler_new_operations_property.py::test_property_get_tag_sync_settings_always_returns_structure:

  - during generate phase (0.60 seconds):
    - Typical runtimes: ~ 0-7 ms, of which ~ 0-4 ms in data generation
    - 100 passing examples, 0 failing examples, 26 invalid examples
    - Events:
      * 56.35%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc'))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_query_handler_new_operations_property.py::test_property_get_tag_sync_settings_no_error_for_any_input:

  - during generate phase (0.66 seconds):
    - Typical runtimes: ~ 0-5 ms, of which ~ 0-1 ms in data generation
    - 100 passing examples, 0 failing examples, 47 invalid examples
    - Events:
      * 49.66%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc'))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_query_handler_new_operations_property.py::test_property_get_drs_capacity_conflicts_returns_structure:

  - during generate phase (0.50 seconds):
    - Typical runtimes: ~ 5-13 ms, of which ~ 1-8 ms in data generation
    - 50 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_query_handler_new_operations_property.py::test_property_get_drs_capacity_conflicts_detects_high_usage:

  - during generate phase (0.35 seconds):
    - Typical runtimes: ~ 3-5 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_query_handler_new_operations_property.py::test_property_get_drs_capacity_conflicts_no_conflict_for_low_usage:

  - during generate phase (0.25 seconds):
    - Typical runtimes: ~ 4-5 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_query_handler_new_operations_property.py::test_property_get_drs_capacity_conflicts_no_error_for_any_input:

  - during generate phase (0.28 seconds):
    - Typical runtimes: ~ 0-6 ms, of which ~ 0-2 ms in data generation
    - 50 passing examples, 0 failing examples, 19 invalid examples
    - Events:
      * 36.23%, Retried draw from text(characters(codec='utf-8', categories=('Zl', 'Zp', 'Co', 'Me', 'Pc', 'Zs', 'Lt', 'Pf', 'Pi', 'Nl', 'Pd', 'Cf', 'Sc', 'Sk', 'Nd', 'Sm', 'Lm', 'No', 'Pe', 'Ps', 'Mc', 'So', 'Po', 'Mn', 'Lo', 'Lu', 'Ll', 'Cn', 'Cc'))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_query_handler_new_operations_property.py::test_property_conflict_severity_critical_for_90_percent:

  - during generate phase (0.36 seconds):
    - Typical runtimes: ~ 3-5 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 2 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_query_handler_new_operations_property.py::test_property_conflict_severity_warning_for_80_percent:

  - during generate phase (0.25 seconds):
    - Typical runtimes: ~ 3-5 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 2 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_recovery_capacity_calculation_property.py::test_property_recovery_capacity_status_calculation:

  - during generate phase (0.03 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_recovery_capacity_calculation_property.py::test_property_recovery_capacity_excludes_staging_accounts:

  - during generate phase (0.06 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_recovery_capacity_calculation_property.py::test_property_ok_status_threshold:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_recovery_capacity_calculation_property.py::test_property_warning_status_threshold:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_recovery_capacity_calculation_property.py::test_property_critical_status_threshold:

  - during generate phase (0.01 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_response_format_property.py::TestResponseFormatProperty::test_api_gateway_mode_returns_wrapped_format:

  - during generate phase (0.12 seconds):
    - Typical runtimes: ~ 0-112 ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_response_format_property.py::TestResponseFormatProperty::test_direct_mode_returns_unwrapped_format:

  - during generate phase (0.12 seconds):
    - Typical runtimes: ~ 1-118 ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_response_format_property.py::TestResponseFormatProperty::test_api_gateway_error_format_consistent:

  - during generate phase (0.00 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_response_format_property.py::TestResponseFormatProperty::test_direct_mode_error_format_consistent:

  - during generate phase (0.00 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_response_format_property.py::TestResponseFormatConsistencyAcrossOperations::test_response_format_consistent_for_success_and_error:

  - during generate phase (0.19 seconds):
    - Typical runtimes: ~ 1-49 ms, of which < 1ms in data generation
    - 6 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_response_format_property.py::TestResponseDataStructureProperty::test_api_gateway_body_always_json_string:

  - during generate phase (0.04 seconds):
    - Typical runtimes: ~ 1-33 ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_response_format_property.py::TestResponseDataStructureProperty::test_direct_mode_returns_dict_not_string:

  - during generate phase (0.05 seconds):
    - Typical runtimes: ~ 1-40 ms, of which < 1ms in data generation
    - 3 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_response_format_property.py::TestResponseFormatJSONSerializability::test_all_responses_json_serializable:

  - during generate phase (0.09 seconds):
    - Typical runtimes: ~ 0-45 ms, of which < 1ms in data generation
    - 6 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_staging_account_persistence_property.py::test_property_staging_account_persistence_round_trip:

  - during generate phase (0.58 seconds):
    - Typical runtimes: ~ 2-6 ms, of which ~ 2-5 ms in data generation
    - 100 passing examples, 0 failing examples, 10 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_staging_account_persistence_property.py::test_property_multiple_staging_accounts_persistence:

  - during generate phase (2.67 seconds):
    - Typical runtimes: ~ 3-46 ms, of which ~ 2-37 ms in data generation
    - 100 passing examples, 0 failing examples, 18 invalid examples
    - Events:
      * 20.34%, Retried draw from FixedKeysDictStrategy(('accountId', 'accountName', 'roleArn', 'externalId'), TupleStrategy((from_regex('\\d{12}', fullmatch=True), text(alphabet=characters(whitelist_categories=('Lu', 'Ll', 'Nd'), whitelist_characters='_-'), min_size=1, max_size=50), builds(lambda account_id, role_name: (f"arn:aws:iam::{account_id}:role/{role_name}"), account_id=from_regex('\\d{12}', fullmatch=True), role_name=from_regex('[\\w+=,.@-]{1,64}', fullmatch=True)), text(alphabet=characters(whitelist_categories=('Lu', 'Ll', 'Nd'), whitelist_characters='_-'), min_size=1, max_size=100)))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=100


tests/unit/test_staging_account_persistence_property.py::test_property_empty_staging_accounts_default:

  - during generate phase (0.55 seconds):
    - Typical runtimes: ~ 2-5 ms, of which ~ 2-4 ms in data generation
    - 100 passing examples, 0 failing examples, 10 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_staging_account_removal_property.py::test_property_staging_account_removal_completeness:

  - during generate phase (3.33 seconds):
    - Typical runtimes: ~ 6-40 ms, of which ~ 4-19 ms in data generation
    - 100 passing examples, 0 failing examples, 34 invalid examples
    - Events:
      * 22.39%, Retried draw from FixedKeysDictStrategy(('accountId', 'accountName', 'roleArn', 'externalId'), TupleStrategy((from_regex('\\d{12}', fullmatch=True), text(alphabet=characters(whitelist_categories=('Lu', 'Ll', 'Nd'), whitelist_characters='_-'), min_size=1, max_size=50), builds(lambda acc_id: f"arn:aws:iam::{acc_id}:role/TestRole", from_regex('\\d{12}', fullmatch=True)), text(min_size=1, max_size=100)))).filter(not_yet_in_unique_list) to satisfy filter
      * 4.48%, invalid because: Aborted test because unable to satisfy FixedKeysDictStrategy(('accountId', 'accountName', 'roleArn', 'externalId'), TupleStrategy((from_regex('\\d{12}', fullmatch=True), text(alphabet=characters(whitelist_categories=('Lu', 'Ll', 'Nd'), whitelist_characters='_-'), min_size=1, max_size=50), builds(lambda acc_id: f"arn:aws:iam::{acc_id}:role/TestRole", from_regex('\\d{12}', fullmatch=True)), text(min_size=1, max_size=100)))).filter(not_yet_in_unique_list)

  - Stopped because settings.max_examples=100


tests/unit/test_staging_account_removal_property.py::test_property_remove_all_staging_accounts_sequentially:

  - during generate phase (1.08 seconds):
    - Typical runtimes: ~ 5-26 ms, of which ~ 2-11 ms in data generation
    - 50 passing examples, 0 failing examples, 8 invalid examples
    - Events:
      * 10.34%, Retried draw from FixedKeysDictStrategy(('accountId', 'accountName', 'roleArn', 'externalId'), TupleStrategy((from_regex('\\d{12}', fullmatch=True), text(alphabet=characters(whitelist_categories=('Lu', 'Ll', 'Nd'), whitelist_characters='_-'), min_size=1, max_size=50), builds(lambda acc_id: f"arn:aws:iam::{acc_id}:role/TestRole", from_regex('\\d{12}', fullmatch=True)), text(min_size=1, max_size=100)))).filter(not_yet_in_unique_list) to satisfy filter

  - Stopped because settings.max_examples=50


tests/unit/test_staging_sync_property.py::test_property_11_handle_sync_staging_accounts_uses_region_filtering:

  - during generate phase (0.09 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 10 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_staging_sync_property.py::test_property_11_auto_extend_staging_servers_uses_region_filtering:

  - during generate phase (0.27 seconds):
    - Typical runtimes: ~ 1-2 ms, of which ~ 0-2 ms in data generation
    - 100 passing examples, 0 failing examples, 26 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_staging_sync_property.py::test_property_5_api_call_reduction:

  - during generate phase (0.39 seconds):
    - Typical runtimes: ~ 35-41 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_staging_sync_property.py::test_property_12_cross_account_iam_assumptions_limited:

  - during generate phase (0.01 seconds):
    - Typical runtimes: ~ 0-1 ms, of which < 1ms in data generation
    - 10 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because nothing left to do


tests/unit/test_tag_sync_property.py::test_property_tag_sync_uses_active_region_filtering:

  - during generate phase (0.08 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 3 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_tag_sync_property.py::test_property_tag_sync_region_count_matches:

  - during generate phase (0.04 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 4 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_tag_sync_property.py::test_property_tag_sync_skips_inactive_regions:

  - during generate phase (0.15 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 7 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_tag_sync_property.py::test_property_tag_sync_api_call_reduction:

  - during generate phase (0.04 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 40 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_target_account_addition_property.py::test_property_explicit_arn_precedence:

  - during generate phase (7.35 seconds):
    - Typical runtimes: ~ 1-286 ms, of which ~ 0-1 ms in data generation
    - 50 passing examples, 0 failing examples, 4 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_target_account_addition_property.py::test_property_optional_role_arn_acceptance:

  - during generate phase (7.34 seconds):
    - Typical runtimes: ~ 0-289 ms, of which < 1ms in data generation
    - 50 passing examples, 0 failing examples, 4 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_target_account_addition_property.py::test_property_api_response_includes_role_arn:

  - during generate phase (4.44 seconds):
    - Typical runtimes: ~ 0-306 ms, of which < 1ms in data generation
    - 30 passing examples, 0 failing examples, 2 invalid examples

  - Stopped because settings.max_examples=30


tests/unit/test_validation_error_handling_property.py::test_property_validation_error_handling_role_failures:

  - during generate phase (0.45 seconds):
    - Typical runtimes: ~ 1-4 ms, of which ~ 1-3 ms in data generation
    - 100 passing examples, 0 failing examples, 30 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_validation_error_handling_property.py::test_property_validation_error_handling_drs_uninitialized:

  - during generate phase (0.53 seconds):
    - Typical runtimes: ~ 1-4 ms, of which ~ 1-3 ms in data generation
    - 100 passing examples, 0 failing examples, 22 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_validation_error_handling_property.py::test_property_validation_error_handling_drs_other_errors:

  - during generate phase (0.24 seconds):
    - Typical runtimes: ~ 1-4 ms, of which ~ 1-3 ms in data generation
    - 50 passing examples, 0 failing examples, 21 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_validation_error_handling_property.py::test_property_validation_error_handling_invalid_account_id:

  - during generate phase (0.17 seconds):
    - Typical runtimes: ~ 0-3 ms, of which ~ 0-2 ms in data generation
    - 50 passing examples, 0 failing examples, 14 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_validation_error_handling_property.py::test_property_validation_error_handling_missing_required_fields:

  - during generate phase (0.18 seconds):
    - Typical runtimes: ~ 1-3 ms, of which ~ 1-2 ms in data generation
    - 50 passing examples, 0 failing examples, 12 invalid examples

  - Stopped because settings.max_examples=50


tests/unit/test_validation_result_completeness_property.py::test_property_validation_result_completeness_success:

  - during generate phase (0.58 seconds):
    - Typical runtimes: ~ 1-5 ms, of which ~ 1-3 ms in data generation
    - 100 passing examples, 0 failing examples, 21 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_validation_result_completeness_property.py::test_property_validation_result_completeness_role_failure:

  - during generate phase (0.46 seconds):
    - Typical runtimes: ~ 1-4 ms, of which ~ 1-3 ms in data generation
    - 100 passing examples, 0 failing examples, 38 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_validation_result_completeness_property.py::test_property_validation_result_completeness_drs_uninitialized:

  - during generate phase (0.48 seconds):
    - Typical runtimes: ~ 1-4 ms, of which ~ 1-3 ms in data generation
    - 100 passing examples, 0 failing examples, 32 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_warning_generation_property.py::test_property_warning_generation_per_account:

  - during generate phase (1.00 seconds):
    - Typical runtimes: ~ 2-13 ms, of which ~ 2-12 ms in data generation
    - 100 passing examples, 0 failing examples, 1 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_warning_generation_property.py::test_property_combined_warnings:

  - during generate phase (0.07 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


tests/unit/test_warning_generation_property.py::test_property_no_warnings_for_ok_status:

  - during generate phase (0.03 seconds):
    - Typical runtimes: < 1ms, of which < 1ms in data generation
    - 100 passing examples, 0 failing examples, 0 invalid examples

  - Stopped because settings.max_examples=100


=========================== short test summary info ============================
FAILED tests/unit/test_iam_utils_unit.py::TestLogDirectInvocation::test_log_successful_invocation
FAILED tests/unit/test_iam_utils_unit.py::TestLogDirectInvocation::test_log_failed_invocation
FAILED tests/unit/test_iam_utils_unit.py::TestLogDirectInvocation::test_log_masks_sensitive_parameters
FAILED tests/unit/test_iam_utils_unit.py::TestLogDirectInvocation::test_log_truncates_large_results
FAILED tests/unit/test_iam_utils_unit.py::TestLogDirectInvocation::test_log_includes_context_metadata
FAILED tests/unit/test_iam_utils_unit.py::TestLogDirectInvocation::test_log_handles_nested_sensitive_params
FAILED tests/unit/test_iam_utils_unit.py::TestLogDirectInvocation::test_log_handles_exception
FAILED tests/unit/test_iam_utils_unit.py::TestIntegrationScenarios::test_authorized_step_functions_invocation
FAILED tests/unit/test_iam_utils_unit.py::TestIntegrationScenarios::test_unauthorized_user_invocation
FAILED tests/unit/test_inventory_fallback_property.py::test_property_10_inventory_updated_during_fallback
FAILED tests/unit/test_inventory_fallback_property.py::test_property_13_topology_preserved_on_update
FAILED tests/unit/test_inventory_fallback_property.py::test_property_13_topology_captured_for_new_server
FAILED tests/unit/test_inventory_fallback_property.py::test_property_13_get_failback_topology_returns_correct_data
FAILED tests/unit/test_inventory_query_property.py::test_property_inventory_freshness_check
FAILED tests/unit/test_inventory_query_property.py::test_property_custom_freshness_threshold
FAILED tests/unit/test_inventory_query_property.py::test_property_stale_inventory_returns_empty
FAILED tests/unit/test_inventory_query_property.py::test_property_inventory_data_completeness
FAILED tests/unit/test_inventory_query_property.py::test_property_all_servers_have_required_fields
FAILED tests/unit/test_inventory_query_unit.py::TestIsInventoryFresh::test_fresh_inventory_returns_true
FAILED tests/unit/test_inventory_query_unit.py::TestIsInventoryFresh::test_custom_max_age
FAILED tests/unit/test_inventory_query_unit.py::TestQueryInventoryByRegions::test_query_single_region
FAILED tests/unit/test_inventory_query_unit.py::TestQueryInventoryByRegions::test_query_multiple_regions
FAILED tests/unit/test_inventory_query_unit.py::TestQueryInventoryByRegions::test_query_with_hostname_filter
FAILED tests/unit/test_inventory_query_unit.py::TestQueryInventoryByRegions::test_query_with_replication_state_filter
FAILED tests/unit/test_inventory_query_unit.py::TestQueryInventoryByRegions::test_query_with_pagination
FAILED tests/unit/test_inventory_query_unit.py::TestQueryInventoryByStagingAccount::test_query_staging_account
FAILED tests/unit/test_inventory_query_unit.py::TestQueryInventoryByStagingAccount::test_query_staging_account_with_regions
FAILED tests/unit/test_inventory_query_unit.py::TestGetServerById::test_get_server_with_region
FAILED tests/unit/test_inventory_query_unit.py::TestGetServerById::test_get_server_without_region
FAILED tests/unit/test_inventory_sync_property.py::test_property_region_status_table_updates
FAILED tests/unit/test_inventory_sync_property.py::test_property_region_status_update_idempotency
FAILED tests/unit/test_inventory_sync_property.py::test_property_region_status_update_overwrites_previous
FAILED tests/unit/test_inventory_sync_property.py::test_region_status_update_specific_examples
FAILED tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_status_field_validity
FAILED tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_timestamp_presence_for_configured_status
FAILED tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_server_configs_structure_validity
FAILED tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_not_configured_status_no_timestamp_required
FAILED tests/unit/test_launch_config_service_property.py::TestProperty4ConfigurationStatusSchemaValidity::test_property_4_camelcase_naming_convention
FAILED tests/unit/test_launch_config_service_property.py::TestProperty8ConfigurationDriftDetection::test_property_8_no_drift_when_hashes_match
FAILED tests/unit/test_launch_config_service_property.py::TestProperty8ConfigurationDriftDetection::test_property_8_partial_drift_detection
FAILED tests/unit/test_launch_config_service_property.py::TestProperty8ConfigurationDriftDetection::test_property_8_drift_with_missing_stored_config
FAILED tests/unit/test_launch_config_service_property.py::TestProperty8ConfigurationDriftDetection::test_property_8_drift_with_not_configured_status
FAILED tests/unit/test_launch_config_service_property.py::TestProperty6ReapplyOperationCompleteness::test_property_6_status_reflects_all_success
FAILED tests/unit/test_launch_config_service_property.py::TestProperty6ReapplyOperationCompleteness::test_property_6_status_reflects_partial_success
FAILED tests/unit/test_launch_config_service_property.py::TestProperty6ReapplyOperationCompleteness::test_property_6_reapply_updates_timestamps
FAILED tests/unit/test_launch_config_service_property.py::TestProperty5ErrorVisibility::test_property_5_partial_failure_error_visibility
FAILED tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_ready_status_skips_config_application
FAILED tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_ready_status_has_valid_config_hashes
FAILED tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_non_ready_status_requires_config_application
FAILED tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_missing_status_requires_config_application
FAILED tests/unit/test_launch_config_service_property.py::TestProperty3WaveExecutionFastPath::test_property_3_fast_path_decision_is_deterministic
FAILED tests/unit/test_launch_config_service_property.py::TestProperty11StatusTransitionValidity::test_property_11_success_transitions_to_ready
FAILED tests/unit/test_launch_config_service_unit.py::TestPersistConfigStatus::test_persist_valid_status_succeeds
FAILED tests/unit/test_launch_config_service_unit.py::TestPersistConfigStatus::test_persist_with_server_configs
FAILED tests/unit/test_launch_config_service_unit.py::TestPersistConfigStatus::test_persist_with_errors
FAILED tests/unit/test_launch_config_service_unit.py::TestPersistConfigStatus::test_persist_uses_atomic_update
FAILED tests/unit/test_launch_config_service_unit.py::TestGetConfigStatus::test_get_existing_status_returns_status
FAILED tests/unit/test_launch_config_service_unit.py::TestGetConfigStatus::test_get_status_without_launch_config_returns_default
FAILED tests/unit/test_launch_config_service_unit.py::TestGetConfigStatus::test_get_status_group_not_found_raises_error
FAILED tests/unit/test_launch_config_service_unit.py::TestGetConfigStatus::test_get_status_with_server_configs
FAILED tests/unit/test_launch_config_service_unit.py::TestGetConfigStatus::test_get_status_with_errors
FAILED tests/unit/test_launch_config_service_unit.py::TestEnvironmentVariableHandling::test_missing_table_name_env_var_raises_error
FAILED tests/unit/test_multi_account_query_parallelism_property.py::test_property_multi_account_query_parallelism
FAILED tests/unit/test_multi_account_query_parallelism_property.py::test_property_concurrent_region_queries_per_account
FAILED tests/unit/test_multi_account_query_parallelism_property.py::test_property_parallel_execution_not_sequential
FAILED tests/unit/test_multi_account_query_parallelism_property.py::test_edge_case_no_staging_accounts
FAILED tests/unit/test_multi_account_query_parallelism_property.py::test_edge_case_many_staging_accounts
FAILED tests/unit/test_multi_account_query_parallelism_property.py::test_edge_case_query_failure_continues
FAILED tests/unit/test_staging_account_sync_comprehensive.py::TestHandleSyncStagingAccounts::test_successful_sync_with_active_regions
FAILED tests/unit/test_staging_account_sync_comprehensive.py::TestGetStagingAccountServers::test_uses_inventory_database_when_fresh
========== 70 failed, 1301 passed, 18 warnings in 1349.69s (0:22:29) ===========
