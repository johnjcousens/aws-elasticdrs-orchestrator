AWSTemplateFormatVersion: '2010-09-09'
Description: 'Step Functions State Machine for DRS Orchestration - Archive pattern with OutputPath'

Parameters:
  ProjectName:
    Type: String
    Description: 'Project name for resource naming'
    Default: 'drs-orchestration'
  
  Environment:
    Type: String
    Description: 'Environment name (dev, test, prod)'
    Default: 'test'
  
  OrchestrationLambdaArn:
    Type: String
    Description: 'ARN of the orchestration Lambda function'

Resources:
  # Step Functions State Machine - Archive pattern: Lambda owns ALL state via OutputPath
  DRSOrchestrationStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${ProjectName}-state-machine-${Environment}'
      RoleArn: !GetAtt StateMachineRole.Arn
      Definition:
        Comment: 'DRS Recovery Plan Orchestration - Archive pattern with OutputPath (Lambda owns state)'
        StartAt: 'InitiateWavePlan'
        States:
          # Step 1: Initialize the wave plan - Lambda returns FULL state
          InitiateWavePlan:
            Type: Task
            Resource: 'arn:aws:states:::lambda:invoke'
            Parameters:
              FunctionName: !Ref OrchestrationLambdaArn
              Payload:
                action: 'begin'
                execution.$: '$.Execution.Id'
                plan.$: '$.Plan'
                isDrill.$: '$.IsDrill'
            OutputPath: '$.Payload'
            Next: 'DetermineWavePlanState'
            Retry:
              - ErrorEquals:
                  - 'Lambda.ServiceException'
                  - 'Lambda.AWSLambdaException'
                  - 'Lambda.SdkClientException'
                IntervalSeconds: 2
                MaxAttempts: 6
                BackoffRate: 2
          
          # Step 2: Check overall plan state
          DetermineWavePlanState:
            Type: Choice
            Choices:
              # Check for failure
              - Variable: '$.status'
                StringEquals: 'failed'
                Next: 'PlanFailed'
              # Check for timeout
              - Variable: '$.status'
                StringEquals: 'timeout'
                Next: 'PlanTimeout'
              # Check for paused (PauseBeforeWave)
              - Variable: '$.status'
                StringEquals: 'paused'
                Next: 'WaitForResume'
              # Check if all waves completed
              - Variable: '$.all_waves_completed'
                BooleanEquals: true
                Next: 'PlanCompleted'
              # Otherwise check wave state
              - Variable: '$.all_waves_completed'
                BooleanEquals: false
                Next: 'DetermineWaveState'
            Default: 'DetermineWaveState'
          
          # Step 3: Check current wave state
          DetermineWaveState:
            Type: Choice
            Choices:
              # Check for failure
              - Variable: '$.status'
                StringEquals: 'failed'
                Next: 'PlanFailed'
              # Check for timeout
              - Variable: '$.status'
                StringEquals: 'timeout'
                Next: 'PlanTimeout'
              # Check if all waves completed (after wave completion)
              - Variable: '$.all_waves_completed'
                BooleanEquals: true
                Next: 'PlanCompleted'
              # Check if current wave is still in progress
              - Variable: '$.wave_completed'
                BooleanEquals: false
                Next: 'WaitForWaveUpdate'
              # Wave completed, check plan state
              - Variable: '$.wave_completed'
                BooleanEquals: true
                Next: 'DetermineWavePlanState'
            Default: 'WaitForWaveUpdate'
          
          # Step 4: Wait before polling
          WaitForWaveUpdate:
            Type: Wait
            SecondsPath: '$.current_wave_update_time'
            Next: 'UpdateWaveStatus'
          
          # Pause state: Wait for external resume signal (callback pattern)
          # SendTaskSuccess output becomes the state (no Payload wrapper for callbacks)
          WaitForResume:
            Type: Task
            Resource: 'arn:aws:states:::lambda:invoke.waitForTaskToken'
            Parameters:
              FunctionName: !Ref OrchestrationLambdaArn
              Payload:
                action: 'store_task_token'
                application.$: '$'
                taskToken.$: '$$.Task.Token'
            # NOTE: No OutputPath here - callback output is returned directly at root level
            TimeoutSeconds: 86400
            Next: 'ResumeWavePlan'
            Catch:
              - ErrorEquals:
                  - 'States.Timeout'
                Next: 'PlanTimeout'
          
          # After resume, start the next wave - Lambda returns FULL state
          ResumeWavePlan:
            Type: Task
            Resource: 'arn:aws:states:::lambda:invoke'
            Parameters:
              FunctionName: !Ref OrchestrationLambdaArn
              Payload:
                action: 'resume_wave'
                application.$: '$'
            OutputPath: '$.Payload'
            Next: 'DetermineWaveState'
            Retry:
              - ErrorEquals:
                  - 'Lambda.ServiceException'
                  - 'Lambda.AWSLambdaException'
                  - 'Lambda.SdkClientException'
                IntervalSeconds: 2
                MaxAttempts: 6
                BackoffRate: 2
          
          # Step 5: Poll DRS job status - Lambda returns FULL state
          UpdateWaveStatus:
            Type: Task
            Resource: 'arn:aws:states:::lambda:invoke'
            Parameters:
              FunctionName: !Ref OrchestrationLambdaArn
              Payload:
                action: 'update_wave_status'
                application.$: '$'
            OutputPath: '$.Payload'
            Next: 'DetermineWaveState'
            Retry:
              - ErrorEquals:
                  - 'Lambda.ServiceException'
                  - 'Lambda.AWSLambdaException'
                  - 'Lambda.SdkClientException'
                IntervalSeconds: 2
                MaxAttempts: 6
                BackoffRate: 2
          
          # Success state
          PlanCompleted:
            Type: Succeed
          
          # Failure states
          PlanFailed:
            Type: Fail
            Error: 'PlanExecutionFailed'
            Cause: 'DRS recovery plan execution failed'
          
          PlanTimeout:
            Type: Fail
            Error: 'PlanExecutionTimeout'
            Cause: 'DRS recovery plan execution timed out'
  
  # IAM Role for Step Functions
  StateMachineRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-statemachine-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: states.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: !Sub '${ProjectName}-statemachine-policy-${Environment}'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'lambda:InvokeFunction'
                Resource: !Ref OrchestrationLambdaArn
              - Effect: Allow
                Action:
                  - 'logs:CreateLogDelivery'
                  - 'logs:GetLogDelivery'
                  - 'logs:UpdateLogDelivery'
                  - 'logs:DeleteLogDelivery'
                  - 'logs:ListLogDeliveries'
                  - 'logs:PutResourcePolicy'
                  - 'logs:DescribeResourcePolicies'
                  - 'logs:DescribeLogGroups'
                Resource: '*'

Outputs:
  StateMachineArn:
    Description: 'ARN of the DRS Orchestration State Machine'
    Value: !Ref DRSOrchestrationStateMachine
    Export:
      Name: !Sub '${ProjectName}-state-machine-arn-${Environment}'
  
  StateMachineName:
    Description: 'Name of the DRS Orchestration State Machine'
    Value: !GetAtt DRSOrchestrationStateMachine.Name
    Export:
      Name: !Sub '${ProjectName}-state-machine-name-${Environment}'
