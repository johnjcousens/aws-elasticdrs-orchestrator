schemaVersion: '0.3'
description: |
  EC2 AMI Backup and Launch Template Creation Automation
  
  This automation creates a complete backup solution for EC2 instances by generating both an AMI backup
  and a launch template that can be used for disaster recovery or scaling operations.
  
  Workflow:
  
  1. Identifies target instance by ID or Name tag
  
  2. Stops instance if running to ensure consistent backup
  
  3. Creates AMI backup with retention metadata
  
  4. Waits for AMI to become available
  
  5. Creates launch template using backup AMI with original network configuration
  
  Key Features:
  - Flexible instance identification (supports both instance ID and Name tag)
  - Automatic instance stopping for filesystem consistency
  - AMI retention tagging for lifecycle management
  - Launch template preserves original instance configuration
  - Comprehensive error handling and status reporting
  
  Use Cases:
  - Disaster recovery preparation
  - Pre-maintenance backups
  - Template creation for Auto Scaling Groups
  - Instance migration preparation

assumeRole: 'arn:aws:iam::140023385391:role/drs-plan-automation-lambda-prod-iam-usw2'
parameters:

  InstanceInput:
    type: String
    default: 'MyServerName'
    description: 'Instance to backup. Enter either the instance Name tag (e.g., MyServer) or instance ID (e.g., i-0123456789abcdef0).'
    
  TargetRegion:
    type: String
    default: 'us-west-2'
    allowedValues:
      - 'us-east-1'         # US East (N. Virginia)
      - 'us-east-2'         # US East (Ohio)
      - 'us-west-1'         # US West (N. California)
      - 'us-west-2'         # US West (Oregon)
      - 'ca-central-1'      # Canada (Central)
      - 'ca-west-1'         # Canada (West)
      - 'eu-central-1'      # Europe (Frankfurt)
      - 'eu-central-2'      # Europe (Zurich)
      - 'eu-west-1'         # Europe (Ireland)
      - 'eu-west-2'         # Europe (London)
      - 'eu-west-3'         # Europe (Paris)
      - 'eu-north-1'        # Europe (Stockholm)
      - 'eu-south-1'        # Europe (Milan)
      - 'eu-south-2'        # Europe (Spain)
      - 'ap-east-1'         # Asia Pacific (Hong Kong)
      - 'ap-south-1'        # Asia Pacific (Mumbai)
      - 'ap-south-2'        # Asia Pacific (Hyderabad)
      - 'ap-southeast-1'    # Asia Pacific (Singapore)
      - 'ap-southeast-2'    # Asia Pacific (Sydney)
      - 'ap-southeast-3'    # Asia Pacific (Jakarta)
      - 'ap-southeast-4'    # Asia Pacific (Melbourne)
      - 'ap-northeast-1'    # Asia Pacific (Tokyo)
      - 'ap-northeast-2'    # Asia Pacific (Seoul)
      - 'ap-northeast-3'    # Asia Pacific (Osaka)
      - 'me-south-1'        # Middle East (Bahrain)
      - 'af-south-1'        # Africa (Cape Town)
      - 'sa-east-1'         # South America (SÃ£o Paulo)
    description: 'AWS region where your instance is located. Select from the dropdown list.'
    
  RetentionDays:
    type: Integer
    default: 7
    description: 'How many days to keep the AMI backup before cleanup. Common values: 7 (week), 30 (month), 90 (quarter).'

mainSteps:
  - name: ResolveInstance
    action: 'aws:executeScript'
    description: |
      STEP 1: Resolve instance by ID or Name tag
      
      This step intelligently identifies the target EC2 instance using either direct instance ID
      or Name tag search, providing flexible input handling for different use cases.
      
      RESOLUTION LOGIC:
      - Detects instance ID format (i-[0-9a-f]{8,17}) for direct targeting
      - Searches by Name tag for instances in running, stopped, or stopping states
      - Extracts complete instance metadata for subsequent operations
      - Validates instance existence and accessibility
      
      INPUT VALIDATION:
      - Instance ID must match AWS format specification
      - Name tag search must return exactly one instance
      - Instance must be in valid state for backup operations
      - All required metadata must be extractable
      
      OUTPUT PREPARATION:
      - Normalizes instance identification across input methods
      - Extracts network configuration for launch template
      - Preserves original tags for metadata consistency
      - Prepares IAM profile information if present
      
      ERROR HANDLING:
      - Clear error messages for instance not found scenarios
      - Validation of required instance properties
      - Graceful handling of missing optional metadata
    inputs:
      Runtime: python3.11
      Handler: resolve_instance
      Script: |
        import boto3
        import re
        
        def resolve_instance(events, context):
            instance_input = events['InstanceInput']
            region = events['TargetRegion']
            
            ec2 = boto3.client('ec2', region_name=region)
            
            if re.match(r'^i-[0-9a-f]{8,17}$', instance_input):
                response = ec2.describe_instances(InstanceIds=[instance_input])
            else:
                response = ec2.describe_instances(
                    Filters=[
                        {'Name': 'tag:Name', 'Values': [instance_input]},
                        {'Name': 'instance-state-name', 'Values': ['running', 'stopped', 'stopping']}
                    ]
                )
                
                if not response['Reservations']:
                    raise Exception(f"No instance found with Name tag: {instance_input}")
            
            instance = response['Reservations'][0]['Instances'][0]
            
            # Use original input for naming (either Name tag or Instance ID)
            instance_name = next((tag['Value'] for tag in instance.get('Tags', []) if tag['Key'] == 'Name'), instance['InstanceId'])
            
            return {
                'InstanceId': instance['InstanceId'],
                'InstanceName': instance_name,
                'InputName': instance_input,
                'InstanceType': instance['InstanceType'],
                'SubnetId': instance['SubnetId'],
                'PrivateIpAddress': instance['PrivateIpAddress'],
                'SecurityGroups': instance['SecurityGroups'],
                'IamInstanceProfile': instance.get('IamInstanceProfile', {}).get('Arn', ''),
                'Tags': instance.get('Tags', [])
            }
      
      InputPayload:
        InstanceInput: '{{ InstanceInput }}'
        TargetRegion: '{{ TargetRegion }}'
    
    outputs:
      - Name: InstanceId
        Selector: $.Payload.InstanceId
        Type: String
      - Name: InstanceName
        Selector: $.Payload.InstanceName
        Type: String
      - Name: InputName
        Selector: $.Payload.InputName
        Type: String
      - Name: InstanceType
        Selector: $.Payload.InstanceType
        Type: String
      - Name: SubnetId
        Selector: $.Payload.SubnetId
        Type: String
      - Name: PrivateIpAddress
        Selector: $.Payload.PrivateIpAddress
        Type: String
      - Name: SecurityGroups
        Selector: $.Payload.SecurityGroups
        Type: MapList
      - Name: IamInstanceProfile
        Selector: $.Payload.IamInstanceProfile
        Type: String
      - Name: Tags
        Selector: $.Payload.Tags
        Type: MapList

  - name: StopInstance
    action: 'aws:executeAwsApi'
    description: |
      STEP 2: Stop instance if running
      
      Ensures instance is in stopped state for consistent AMI backup creation.
      Running instances can have inconsistent filesystem states during backup.
      
      OPERATION BEHAVIOR:
      - Issues stop command only if instance is currently running
      - Gracefully handles already stopped instances
      - Uses onFailure: Continue to handle edge cases
      - Does not wait for completion (handled in next step)
      
      CONSISTENCY BENEFITS:
      - Ensures filesystem consistency in AMI backup
      - Prevents data corruption during snapshot process
      - Maintains application state integrity
      - Reduces backup creation time and reliability issues
    inputs:
      Service: ec2
      Api: StopInstances
      InstanceIds:
        - '{{ ResolveInstance.InstanceId }}'
    onFailure: Continue

  - name: WaitForStopped
    action: 'aws:waitForAwsResourceProperty'
    description: |
      STEP 3: Wait for instance to reach stopped state
      
      Waits for instance to completely stop before proceeding with AMI creation.
      This ensures filesystem consistency and prevents backup corruption.
      
      WAIT CONFIGURATION:
      - Monitors instance state via DescribeInstances API
      - Timeout set to 600 seconds (10 minutes) for safety
      - Polls at regular intervals until stopped state achieved
      - Fails automation if instance cannot be stopped within timeout
      
      STATE VALIDATION:
      - Confirms instance reaches 'stopped' state specifically
      - Handles intermediate states (stopping) appropriately
      - Provides clear error if timeout exceeded
      - Ensures readiness for consistent AMI creation
    inputs:
      Service: ec2
      Api: DescribeInstances
      InstanceIds:
        - '{{ ResolveInstance.InstanceId }}'
      PropertySelector: '$.Reservations[0].Instances[0].State.Name'
      DesiredValues:
        - stopped
    timeoutSeconds: 600

  - name: CreateAMI
    action: 'aws:executeScript'
    description: |
      STEP 4: Create AMI backup with immediate tagging
      
      Creates AMI backup of the stopped instance with timestamp-based naming
      and immediate tagging for identification and management.
      
      AMI CREATION PROCESS:
      - Generates unique AMI name with timestamp for identification
      - Uses NoReboot=True since instance is already stopped
      - Creates comprehensive description with source instance details
      - Immediately applies Name tag for AWS console visibility
      
      NAMING CONVENTION:
      - Format: backup-{input_name}-{timestamp}
      - Timestamp format: YYYY-MM-DD_HH.MM.SS
      - Ensures uniqueness across multiple backup operations
      - Maintains traceability to source instance
      
      IMMEDIATE TAGGING:
      - Applies Name tag immediately after AMI creation
      - Enables proper identification in AWS console
      - Supports subsequent metadata tagging operations
      - Prevents orphaned AMIs without identification
    inputs:
      Runtime: python3.11
      Handler: create_ami
      Script: |
        import boto3
        from datetime import datetime
        
        def create_ami(events, context):
            region = events['TargetRegion']
            instance_id = events['InstanceId']
            input_name = events['InputName']
            
            ec2 = boto3.client('ec2', region_name=region)
            
            # Generate AMI name with timestamp
            timestamp = datetime.now().strftime('%Y-%m-%d_%H.%M.%S')
            ami_name = f'backup-{input_name}-{timestamp}'
            
            # Create AMI
            response = ec2.create_image(
                InstanceId=instance_id,
                Name=ami_name,
                Description=f'Backup of {instance_id} created via SSM Automation',
                NoReboot=True
            )
            
            ami_id = response['ImageId']
            
            # Immediately tag the AMI with Name tag
            ec2.create_tags(
                Resources=[ami_id],
                Tags=[
                    {'Key': 'Name', 'Value': ami_name}
                ]
            )
            
            return {
                'ImageId': ami_id,
                'AMIName': ami_name
            }
      
      InputPayload:
        TargetRegion: '{{ TargetRegion }}'
        InstanceId: '{{ ResolveInstance.InstanceId }}'
        InputName: '{{ ResolveInstance.InputName }}'
    
    outputs:
      - Name: ImageId
        Selector: $.Payload.ImageId
        Type: String
      - Name: AMIName
        Selector: $.Payload.AMIName
        Type: String

  - name: WaitForAMI
    action: 'aws:waitForAwsResourceProperty'
    description: |
      STEP 5: Wait for AMI to become available
      
      Waits for AMI creation process to complete before proceeding with launch template creation.
      AMI creation involves EBS snapshot creation which can take significant time.
      
      WAIT CONFIGURATION:
      - Monitors AMI state via DescribeImages API
      - Extended timeout of 1800 seconds (30 minutes) for large instances
      - Polls at regular intervals until available state achieved
      - Accounts for EBS snapshot creation time
      
      AMI STATE PROGRESSION:
      - pending -> available (successful creation)
      - pending -> failed (creation failure)
      - Automation continues only on 'available' state
      - Provides clear error messaging for failed AMI creation
      
      PERFORMANCE CONSIDERATIONS:
      - Timeout accommodates large instance volumes
      - Prevents premature launch template creation
      - Ensures AMI is fully ready for use
      - Handles regional variations in creation time
    inputs:
      Service: ec2
      Api: DescribeImages
      ImageIds:
        - '{{ CreateAMI.ImageId }}'
      PropertySelector: '$.Images[0].State'
      DesiredValues:
        - available
    timeoutSeconds: 1800

  - name: CalculateRetentionDate
    action: 'aws:executeScript'
    description: |
      STEP 6: Calculate AMI deletion date for lifecycle management
      
      Calculates future deletion date based on retention policy for AMI lifecycle management.
      Supports automated cleanup processes and cost optimization strategies.
      
      CALCULATION LOGIC:
      - Adds retention days to current date
      - Formats date in YYYY-MM-DD format for consistency
      - Converts retention days to string for tagging compatibility
      - Uses current execution time as baseline
      
      LIFECYCLE MANAGEMENT:
      - Enables automated AMI cleanup via separate processes
      - Supports cost optimization through retention policies
      - Provides audit trail for backup lifecycle
      - Facilitates compliance with data retention requirements
      
      OUTPUT FORMATTING:
      - DeleteAfter: YYYY-MM-DD format for date comparison
      - RetentionDaysStr: String format for tag value compatibility
      - Consistent formatting across all backup operations
      - Machine-readable format for automation tools
    inputs:
      Runtime: python3.11
      Handler: calculate_date
      Script: |
        from datetime import datetime, timedelta
        
        def calculate_date(events, context):
            retention_days = events['RetentionDays']
            delete_date = (datetime.now() + timedelta(days=retention_days)).strftime('%Y-%m-%d')
            return {
                'DeleteAfter': delete_date,
                'RetentionDaysStr': str(retention_days)
            }
      
      InputPayload:
        RetentionDays: '{{ RetentionDays }}'
    
    outputs:
      - Name: DeleteAfter
        Selector: $.Payload.DeleteAfter
        Type: String
      - Name: RetentionDaysStr
        Selector: $.Payload.RetentionDaysStr
        Type: String

  - name: TagAMIAndSnapshots
    action: 'aws:executeScript'
    description: 'Tag AMI and associated snapshots with instance tags and backup metadata'
    inputs:
      Runtime: python3.11
      Handler: tag_resources
      Script: |
        import boto3
        from datetime import datetime
        
        def tag_resources(events, context):
            region = events['TargetRegion']
            ami_id = events['AmiId']
            instance_tags = events['InstanceTags']
            retention_days = events['RetentionDays']
            delete_after = events['DeleteAfter']
            instance_name = events['InstanceName']
            instance_id = events['InstanceId']
            
            ec2 = boto3.client('ec2', region_name=region)
            
            # Prepare tags - combine instance tags with backup metadata
            all_tags = []
            
            # Add all instance tags (excluding AWS internal tags)
            for tag in instance_tags:
                if not tag['Key'].startswith('aws:'):
                    all_tags.append(tag)
            
            # Add backup-specific metadata tags
            timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
            backup_tags = [
                {'Key': 'SourceInstanceName', 'Value': instance_name},
                {'Key': 'SourceInstance', 'Value': instance_id},
                {'Key': 'CreatedBy', 'Value': 'SSM-Automation'},
                {'Key': 'RetentionDays', 'Value': retention_days},
                {'Key': 'DeleteAfter', 'Value': delete_after},
                {'Key': 'CreationDate', 'Value': timestamp}
            ]
            all_tags.extend(backup_tags)
            
            # Tag the AMI
            ec2.create_tags(Resources=[ami_id], Tags=all_tags)
            
            # Get AMI details to find associated snapshots
            ami_response = ec2.describe_images(ImageIds=[ami_id])
            ami = ami_response['Images'][0]
            
            # Extract snapshot IDs from block device mappings
            snapshot_ids = []
            for bdm in ami.get('BlockDeviceMappings', []):
                if 'Ebs' in bdm and 'SnapshotId' in bdm['Ebs']:
                    snapshot_ids.append(bdm['Ebs']['SnapshotId'])
            
            # Tag all associated snapshots
            if snapshot_ids:
                ec2.create_tags(Resources=snapshot_ids, Tags=all_tags)
            
            return {
                'TaggedSnapshots': snapshot_ids,
                'TagCount': len(all_tags)
            }
      
      InputPayload:
        TargetRegion: '{{ TargetRegion }}'
        AmiId: '{{ CreateAMI.ImageId }}'
        InstanceTags: '{{ ResolveInstance.Tags }}'
        RetentionDays: '{{ CalculateRetentionDate.RetentionDaysStr }}'
        DeleteAfter: '{{ CalculateRetentionDate.DeleteAfter }}'
        InstanceName: '{{ ResolveInstance.InputName }}'
        InstanceId: '{{ ResolveInstance.InstanceId }}'
    
    outputs:
      - Name: TaggedSnapshots
        Selector: $.Payload.TaggedSnapshots
        Type: StringList
      - Name: TagCount
        Selector: $.Payload.TagCount
        Type: Integer

  - name: CreateLaunchTemplate
    action: 'aws:executeScript'
    description: |
      STEP 8: Create launch template with backup AMI
      
      Creates launch template using the backup AMI with complete network and security configuration
      preserved from the original instance for consistent deployment capabilities.
      
      TEMPLATE CONFIGURATION:
      - Uses backup AMI instead of original AMI for recovery scenarios
      - Preserves exact network configuration (subnet, private IP, security groups)
      - Maintains IAM instance profile for proper permissions
      - Filters and applies original instance tags (excludes AWS internal tags)
      
      NETWORK PRESERVATION:
      - Exact subnet placement for network consistency
      - Private IP address preservation for application compatibility
      - Security group configuration maintenance
      - Public IP association disabled for security
      
      METADATA HANDLING:
      - Filters out AWS internal tags (aws:*) to prevent conflicts
      - Preserves custom tags for operational consistency
      - Maintains tag specifications for launched instances
      - Ensures proper resource identification and management
      
      NAMING CONVENTION:
      - Format: {instance_name}-backup-template-{timestamp}
      - Timestamp ensures uniqueness across multiple operations
      - Clear identification of backup-based templates
      - Supports operational tracking and management
      
      DEPLOYMENT READINESS:
      - Template ready for Auto Scaling Group integration
      - Supports manual instance launches
      - Maintains all original instance characteristics
      - Enables consistent recovery and scaling operations
    inputs:
      Runtime: python3.11
      Handler: create_template
      Script: |
        import boto3
        import json
        from datetime import datetime
        
        def create_template(events, context):
            region = events['TargetRegion']
            ami_id = events['AmiId']
            instance_type = events['InstanceType']
            subnet_id = events['SubnetId']
            private_ip = events['PrivateIpAddress']
            security_groups = events['SecurityGroups']
            tags = events['Tags']
            iam_profile = events.get('IamInstanceProfile')
            
            ec2 = boto3.client('ec2', region_name=region)
            
            sg_ids = [sg['GroupId'] for sg in security_groups]
            
            filtered_tags = [tag for tag in tags if not tag['Key'].startswith('aws:')]
            
            template_data = {
                'ImageId': ami_id,
                'InstanceType': instance_type,
                'NetworkInterfaces': [{
                    'DeviceIndex': 0,
                    'SubnetId': subnet_id,
                    'AssociatePublicIpAddress': False,
                    'Groups': sg_ids,
                    'PrivateIpAddresses': [{
                        'Primary': True,
                        'PrivateIpAddress': private_ip
                    }]
                }],
                'TagSpecifications': [{
                    'ResourceType': 'instance',
                    'Tags': filtered_tags
                }]
            }
            
            if iam_profile:
                template_data['IamInstanceProfile'] = {'Arn': iam_profile}
            
            instance_name = next((tag['Value'] for tag in filtered_tags if tag['Key'] == 'Name'), 'unknown')
            timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
            template_name = f"{instance_name}-backup-template-{timestamp}"
            
            response = ec2.create_launch_template(
                LaunchTemplateName=template_name,
                LaunchTemplateData=template_data,
                VersionDescription=f"Created from backup AMI {ami_id}"
            )
            
            # Tag the launch template with instance tags
            template_tags = [tag for tag in tags if not tag['Key'].startswith('aws:')]
            timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
            template_tags.extend([
                {'Key': 'SourceInstanceName', 'Value': events['InstanceName']},
                {'Key': 'SourceInstance', 'Value': events['InstanceId']},
                {'Key': 'CreatedBy', 'Value': 'SSM-Automation'},
                {'Key': 'CreationDate', 'Value': timestamp}
            ])
            
            ec2.create_tags(
                Resources=[response['LaunchTemplate']['LaunchTemplateId']],
                Tags=template_tags
            )
            
            return {
                'LaunchTemplateName': template_name,
                'LaunchTemplateId': response['LaunchTemplate']['LaunchTemplateId']
            }
      
      InputPayload:
        TargetRegion: '{{ TargetRegion }}'
        AmiId: '{{ CreateAMI.ImageId }}'
        InstanceType: '{{ ResolveInstance.InstanceType }}'
        SubnetId: '{{ ResolveInstance.SubnetId }}'
        PrivateIpAddress: '{{ ResolveInstance.PrivateIpAddress }}'
        SecurityGroups: '{{ ResolveInstance.SecurityGroups }}'
        Tags: '{{ ResolveInstance.Tags }}'
        IamInstanceProfile: '{{ ResolveInstance.IamInstanceProfile }}'
        InstanceName: '{{ ResolveInstance.InputName }}'
        InstanceId: '{{ ResolveInstance.InstanceId }}'
    
    outputs:
      - Name: LaunchTemplateName
        Selector: $.Payload.LaunchTemplateName
        Type: String
      - Name: LaunchTemplateId
        Selector: $.Payload.LaunchTemplateId
        Type: String

outputs:
  - CreateAMI.ImageId
  - CreateLaunchTemplate.LaunchTemplateName
  - CreateLaunchTemplate.LaunchTemplateId
  - CalculateRetentionDate.DeleteAfter
  - ResolveInstance.InstanceId