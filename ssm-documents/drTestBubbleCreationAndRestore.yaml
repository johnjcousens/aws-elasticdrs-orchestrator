schemaVersion: '0.3'
description: |
  EC2 Disaster Recovery Instance Isolation and Restoration Automation (Granular)
  
  This automation isolates EC2 instances by replacing all security groups with a single DRS isolated security group,
  or restores instances to their original security group configurations for disaster recovery testing.
  
  Workflow:
  
  1. Validates parameters and parses management CIDR ranges
  
  2. Discovers instances matching tag filters with DRS requirements
  
  3. Creates or configures isolated security group with minimal access rules
  
  4. Processes instances based on action (ISOLATE or RESTORE)
  
  Key Features:
  - Granular steps for better troubleshooting
  - Tag-based instance discovery and filtering
  - Automatic security group creation with DRS-specific rules
  - Tag-based backup system for reliable restoration
  - Database/SQL instance exclusion for safety
  
  Use Cases:
  - Disaster recovery testing isolation
  - Security group backup and restoration
  - Network access control for DR operations
  - Automated instance isolation workflows

assumeRole: 'arn:aws:iam::140023385391:role/drs-plan-automation-lambda-prod-iam-usw2'

parameters:

  Action:
    type: String
    description: 'Action to perform: ISOLATE (replace security groups with isolated one) or RESTORE (restore original security groups from backup tags).'
    allowedValues: [ISOLATE, RESTORE]
  
  IsolatedSecurityGroupName:
    type: String
    default: 'drs-isolated-test'
    description: 'Name for the isolated security group. Will be created with DRS replication (TCP 1500) and management access rules.'
  
  InstanceTag:
    type: String
    default: 'crane:application=c2c'
    description: 'Instance tag filter in key=value or key:value format. Instances must also have AWSDRS=AllowLaunchingIntoThisInstance tag.'
  
  ManagementCidrs:
    type: String
    default: '[{"cidr":"10.255.200.0/21","desc":"CRANE VPN"},{"cidr":"172.30.4.26/32","desc":"DATEX IP Address 1"},{"cidr":"172.30.4.27/32","desc":"DATEX IP Address 2"},{"cidr":"172.30.4.29/32","desc":"DATEX IP Address 3"},{"cidr":"172.30.4.30/32","desc":"DATEX IP Address 4"},{"cidr":"172.19.144.0/21","desc":"AWS WorkSpaces us-west-2"}]'
    description: 'Management CIDR ranges in JSON format. Each entry needs "cidr" and "desc" fields.'

mainSteps:
  - name: ValidateParameters
    action: 'aws:executeScript'
    description: 'Validate and parse input parameters including management CIDR ranges and instance tag format'
    inputs:
      Runtime: python3.11
      Handler: validate_params
      Script: |
        import json
        
        def validate_params(events, context):
            # Parse management CIDR ranges
            try:
                management_cidrs = json.loads(events['ManagementCidrs'])
                if not isinstance(management_cidrs, list):
                    raise ValueError("ManagementCidrs must be a JSON array")
                for cidr in management_cidrs:
                    if not isinstance(cidr, dict) or 'cidr' not in cidr or 'desc' not in cidr:
                        raise ValueError("Each CIDR entry must have 'cidr' and 'desc' fields")
            except Exception as e:
                return {'Error': f'Invalid ManagementCidrs JSON: {str(e)}'}
            
            # Parse tag filter
            tag_filter = events['InstanceTag']
            if '=' in tag_filter:
                tag_key, tag_value = tag_filter.split('=', 1)
            elif ':' in tag_filter:
                tag_key, tag_value = tag_filter.split(':', 1)
            else:
                return {'Error': 'InstanceTag must contain = or : separator'}
            
            if not tag_key or not tag_value:
                return {'Error': 'InstanceTag key and value must both be non-empty'}
            
            return {
                'ManagementCidrs': management_cidrs,
                'TagKey': tag_key,
                'TagValue': tag_value,
                'Status': 'Success'
            }
      
      InputPayload:
        ManagementCidrs: '{{ ManagementCidrs }}'
        InstanceTag: '{{ InstanceTag }}'
    
    outputs:
      - Name: ManagementCidrs
        Selector: $.Payload.ManagementCidrs
        Type: MapList
      - Name: TagKey
        Selector: $.Payload.TagKey
        Type: String
      - Name: TagValue
        Selector: $.Payload.TagValue
        Type: String
      - Name: Status
        Selector: $.Payload.Status
        Type: String

  - name: DiscoverInstances
    action: 'aws:executeScript'
    description: 'Discover instances matching tag filters with DRS requirements and exclude database instances'
    inputs:
      Runtime: python3.11
      Handler: discover_instances
      Script: |
        import boto3
        
        def discover_instances(events, context):
            ec2 = boto3.client('ec2')
            tag_key = events['TagKey']
            tag_value = events['TagValue']
            action = events['Action']
            
            if action == 'ISOLATE':
                # Find instances matching tag filters
                instances = ec2.describe_instances(
                    Filters=[
                        {'Name': f'tag:{tag_key}', 'Values': [tag_value]},
                        {'Name': 'tag:AWSDRS', 'Values': ['AllowLaunchingIntoThisInstance']},
                        {'Name': 'instance-state-name', 'Values': ['running', 'stopped']}
                    ]
                )
            else:  # RESTORE
                # Find instances with backup tags
                instances = ec2.describe_instances(
                    Filters=[
                        {'Name': 'tag-key', 'Values': ['SecurityGroupBackup']},
                        {'Name': 'instance-state-name', 'Values': ['running', 'stopped']}
                    ]
                )
            
            # Process instances and filter out databases
            target_instances = []
            vpc_id = None
            
            for reservation in instances['Reservations']:
                for instance in reservation['Instances']:
                    instance_id = instance['InstanceId']
                    name = next((t['Value'] for t in instance.get('Tags', []) if t['Key'] == 'Name'), '(no name)')
                    
                    # Skip SQL/DB instances
                    if any(x in name.lower() for x in ['sql', 'database', 'db']):
                        continue
                    
                    if not vpc_id:
                        vpc_id = instance['VpcId']
                    
                    target_instances.append({
                        'InstanceId': instance_id,
                        'InstanceName': name,
                        'SecurityGroups': instance['SecurityGroups'],
                        'Tags': instance.get('Tags', [])
                    })
            
            return {
                'TargetInstances': target_instances,
                'VpcId': vpc_id,
                'InstanceCount': len(target_instances)
            }
      
      InputPayload:
        TagKey: '{{ ValidateParameters.TagKey }}'
        TagValue: '{{ ValidateParameters.TagValue }}'
        Action: '{{ Action }}'
    
    outputs:
      - Name: TargetInstances
        Selector: $.Payload.TargetInstances
        Type: MapList
      - Name: VpcId
        Selector: $.Payload.VpcId
        Type: String
      - Name: InstanceCount
        Selector: $.Payload.InstanceCount
        Type: Integer

  - name: CreateSecurityGroup
    action: 'aws:executeScript'
    description: 'Create or configure isolated security group with DRS replication and management access rules'
    isEnd: '{{ eq Action "RESTORE" }}'
    inputs:
      Runtime: python3.11
      Handler: create_security_group
      Script: |
        import boto3
        
        def create_security_group(events, context):
            ec2 = boto3.client('ec2')
            sg_name = events['SecurityGroupName']
            vpc_id = events['VpcId']
            management_cidrs = events['ManagementCidrs']
            
            if not vpc_id:
                return {'Error': 'No VPC ID available - no instances found'}
            
            # Create or get security group
            sg_existed = False
            try:
                sgs = ec2.describe_security_groups(
                    Filters=[
                        {'Name': 'group-name', 'Values': [sg_name]},
                        {'Name': 'vpc-id', 'Values': [vpc_id]}
                    ]
                )
                
                if sgs['SecurityGroups']:
                    isolated_sg = sgs['SecurityGroups'][0]['GroupId']
                    sg_existed = True
                    # Clear existing rules
                    sg = sgs['SecurityGroups'][0]
                    if sg['IpPermissions']:
                        ec2.revoke_security_group_ingress(GroupId=isolated_sg, IpPermissions=sg['IpPermissions'])
                    if sg['IpPermissionsEgress']:
                        ec2.revoke_security_group_egress(GroupId=isolated_sg, IpPermissions=sg['IpPermissionsEgress'])
                else:
                    # Create new security group
                    sg_response = ec2.create_security_group(
                        GroupName=sg_name,
                        Description='DRS isolated security group',
                        VpcId=vpc_id
                    )
                    isolated_sg = sg_response['GroupId']
                    ec2.create_tags(Resources=[isolated_sg], Tags=[{'Key': 'Name', 'Value': sg_name}])
                
                # Add DRS replication rule
                ingress_rules = [{'IpProtocol': 'tcp', 'FromPort': 1500, 'ToPort': 1500, 'IpRanges': [{'CidrIp': '172.16.0.0/12', 'Description': 'DRS replication'}]}]
                egress_rules = []
                
                # Add management access rules
                for mgmt in management_cidrs:
                    ingress_rules.append({'IpProtocol': '-1', 'IpRanges': [{'CidrIp': mgmt['cidr'], 'Description': f"All traffic from {mgmt['desc']}"}]})
                    egress_rules.append({'IpProtocol': '-1', 'IpRanges': [{'CidrIp': mgmt['cidr'], 'Description': f"All traffic to {mgmt['desc']}"}]})
                
                ec2.authorize_security_group_ingress(GroupId=isolated_sg, IpPermissions=ingress_rules)
                ec2.authorize_security_group_egress(GroupId=isolated_sg, IpPermissions=egress_rules)
                
                return {
                    'SecurityGroupId': isolated_sg,
                    'SecurityGroupName': sg_name,
                    'SecurityGroupExisted': sg_existed,
                    'RulesConfigured': len(ingress_rules) + len(egress_rules)
                }
                
            except Exception as e:
                return {'Error': f'Security group error: {str(e)}'}
      
      InputPayload:
        SecurityGroupName: '{{ IsolatedSecurityGroupName }}'
        VpcId: '{{ DiscoverInstances.VpcId }}'
        ManagementCidrs: '{{ ValidateParameters.ManagementCidrs }}'
    
    outputs:
      - Name: SecurityGroupId
        Selector: $.Payload.SecurityGroupId
        Type: String
      - Name: SecurityGroupName
        Selector: $.Payload.SecurityGroupName
        Type: String
      - Name: SecurityGroupExisted
        Selector: $.Payload.SecurityGroupExisted
        Type: Boolean
      - Name: RulesConfigured
        Selector: $.Payload.RulesConfigured
        Type: Integer

  - name: ProcessInstances
    action: 'aws:executeScript'
    description: 'Isolate instances with security group replacement or restore from backup tags based on action'
    inputs:
      Runtime: python3.11
      Handler: process_instances
      Script: |
        import boto3
        
        def process_instances(events, context):
            ec2 = boto3.client('ec2')
            action = events['Action']
            target_instances = events['TargetInstances']
            isolated_sg = events.get('SecurityGroupId')
            sg_name = events.get('SecurityGroupName', '')
            
            count = 0
            processed_instances = []
            skipped_instances = []
            
            if action == 'ISOLATE':
                for instance in target_instances:
                    instance_id = instance['InstanceId']
                    name = instance['InstanceName']
                    
                    # Check if SecurityGroupBackup tag already exists
                    backup_tag_value = None
                    for tag in instance['Tags']:
                        if tag['Key'] == 'SecurityGroupBackup':
                            backup_tag_value = tag['Value']
                            break
                    
                    if backup_tag_value:
                        skipped_instances.append({
                            'InstanceId': instance_id,
                            'InstanceName': name,
                            'Reason': 'SecurityGroupBackup tag already exists'
                        })
                        continue
                    
                    # Get current security group details
                    current_sg_details = []
                    for sg in instance['SecurityGroups']:
                        current_sg_details.append(f"{sg['GroupName']} ({sg['GroupId']})")
                    
                    # Store current SGs in tag
                    current_sgs = ','.join([sg['GroupId'] for sg in instance['SecurityGroups']])
                    
                    ec2.create_tags(
                        Resources=[instance_id],
                        Tags=[{'Key': 'SecurityGroupBackup', 'Value': current_sgs}]
                    )
                    
                    # Isolate
                    ec2.modify_instance_attribute(
                        InstanceId=instance_id,
                        Groups=[isolated_sg]
                    )
                    
                    processed_instances.append({
                        'InstanceId': instance_id,
                        'InstanceName': name,
                        'OriginalSecurityGroups': current_sg_details,
                        'IsolatedSecurityGroup': f'{sg_name} ({isolated_sg})'
                    })
                    count += 1
                
                return {
                    'Message': f'Isolated {count} instances',
                    'ProcessedCount': count,
                    'ProcessedInstances': processed_instances,
                    'SkippedInstances': skipped_instances
                }
            
            elif action == 'RESTORE':
                for instance in target_instances:
                    instance_id = instance['InstanceId']
                    name = instance['InstanceName']
                    
                    # Get backup from tag
                    backup_sgs = None
                    for tag in instance['Tags']:
                        if tag['Key'] == 'SecurityGroupBackup':
                            backup_sgs = tag['Value'].split(',')
                            break
                    
                    if backup_sgs:
                        try:
                            # Get security group names for backup SGs
                            sg_details = ec2.describe_security_groups(GroupIds=backup_sgs)
                            restored_sg_details = []
                            for sg in sg_details['SecurityGroups']:
                                restored_sg_details.append(f"{sg['GroupName']} ({sg['GroupId']})")
                            
                            # Restore security groups
                            ec2.modify_instance_attribute(
                                InstanceId=instance_id,
                                Groups=backup_sgs
                            )
                            
                            # Remove backup tag after successful restore
                            ec2.delete_tags(
                                Resources=[instance_id],
                                Tags=[{'Key': 'SecurityGroupBackup'}]
                            )
                            
                            processed_instances.append({
                                'InstanceId': instance_id,
                                'InstanceName': name,
                                'RestoredSecurityGroups': restored_sg_details
                            })
                            count += 1
                        except Exception as e:
                            processed_instances.append({
                                'InstanceId': instance_id,
                                'InstanceName': name,
                                'Error': str(e)
                            })
                
                failed_count = len([p for p in processed_instances if 'Error' in p])
                return {
                    'Message': f'Restored {count} instances' + (f', {failed_count} failed' if failed_count > 0 else ''),
                    'ProcessedCount': count,
                    'FailedCount': failed_count,
                    'ProcessedInstances': processed_instances
                }
      
      InputPayload:
        Action: '{{ Action }}'
        TargetInstances: '{{ DiscoverInstances.TargetInstances }}'
        SecurityGroupId: '{{ CreateSecurityGroup.SecurityGroupId }}'
        SecurityGroupName: '{{ CreateSecurityGroup.SecurityGroupName }}'
    
    outputs:
      - Name: Message
        Selector: $.Payload.Message
        Type: String
      - Name: ProcessedCount
        Selector: $.Payload.ProcessedCount
        Type: Integer
      - Name: ProcessedInstances
        Selector: $.Payload.ProcessedInstances
        Type: MapList

outputs:
  - ProcessInstances.Message
  - ProcessInstances.ProcessedCount
  - ProcessInstances.ProcessedInstances
  - DiscoverInstances.InstanceCount